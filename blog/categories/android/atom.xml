<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: android | Zhibin's blog]]></title>
  <link href="http://SteveVallay.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://SteveVallay.github.io/"/>
  <updated>2014-01-08T17:06:38+08:00</updated>
  <id>http://SteveVallay.github.io/</id>
  <author>
    <name><![CDATA[zhibin]]></name>
    <email><![CDATA[zhibinwang.q@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[alarm]]></title>
    <link href="http://SteveVallay.github.io/blog/2013/12/27/alarm/"/>
    <updated>2013-12-27T14:40:00+08:00</updated>
    <id>http://SteveVallay.github.io/blog/2013/12/27/alarm</id>
    <content type="html"><![CDATA[<p>关于时间，我们还知之甚少。</p>

<!-- more -->


<p>不知道是谁发现了时间这个 NB 的概念! 有了时间，使得我们可以知道从一个事件到另外一个事件，中间经历了多久。时间参考系的建立，使得我们可以即使在不同的地点也可以取得同步，完成协作。</p>

<p>每个系统都要维持一个时钟系统，一方面维持自身的秩序，另一方面和外界取得一致。</p>

<p>Linux 和 Android 都不例外。在手机上我们需要时间系统提供什么样的服务呢？</p>

<ul>
<li>允许我设置时间/同步时间。</li>
<li>告诉我现在是什么时间。</li>
<li>告诉我系统运行了多长时间。</li>
<li>允许我设置特定时间提醒。</li>
</ul>


<p>先来看看设置特定时间提醒这个功能。</p>

<p>这个特定时间，有两个参考系:</p>

<ul>
<li>RTC</li>
<li>ELAPSED_REALTIME</li>
</ul>


<p><code>RTC</code> 指得就是当前时间,UTC时间，java api <code>System.currentTimeMillis()</code> 返回的时间，通过这个时间我们知道现在是几年几月几日几时几分几秒。</p>

<p><code>ELAPSED_REALTIME</code> 指的是过去的时间，从开机开始过去了多久， java api <code>SystemClock.elapsedRealtime()</code> 返回的时间， 通过这个时间我们知道系统运行了多久。</p>

<p>由于手机系统会有 &ldquo;休眠&rdquo; 状态，特定时间提醒这个服务在 &ldquo;休眠&rdquo; 状态可以有两种选择，唤醒手机提醒，或者不唤醒手机，等待手机被其他原因唤醒后再提醒。针对这个特性，又添加了两种类型:</p>

<ul>
<li>RTC_WAKEUP</li>
<li>ELAPSED_REALTIME_WAKEUP</li>
</ul>


<p><code>RTC_WAKEUP</code> 基于 UTC 时间，唤醒手机进行提醒，<code>RTC</code> 默认不会唤醒手机。</p>

<p><code>ELAPSED_REALTIME_WAKEUP</code> 类似的，基于开机过去时间，唤醒手机进行提醒。<code>ELAPSED_REALTIME</code> 不会。</p>

<p>先看下在 app layer 如何设置特定时间提醒:</p>

<p><code>java packages/apps/DeskClock/src/com/android/deskclock/alarms/AlarmStateManager.java
 AlarmManager am = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
 am.set(AlarmManager.RTC_WAKEUP, timeInMillis, pendingIntent);
</code></p>

<p>获取 AlarmManager ，设置在 RTC 时间  <code>timeInMillis</code> 唤醒并触发 <code>pendingIntent</code> 提醒。</p>

<p>我们知道 AlarmManager 是 AlarmManagerService 的代理，它最后会 IPC到 AlarmManagerService 调用相关的接口。</p>

<p>``` java framework/base/core/java/android/app/AlarmManager.java</p>

<pre><code> public void setExact(int type, long triggerAtMillis, PendingIntent operation) {
     setImpl(type, triggerAtMillis, WINDOW_EXACT, 0, operation, null);
 }

 private void setImpl(int type, long triggerAtMillis, long windowMillis, long intervalMillis,
         PendingIntent operation, WorkSource workSource) {
</code></pre>

<p>&hellip;
  try {</p>

<pre><code>         mService.set(type, triggerAtMillis, windowMillis, intervalMillis, operation,
                 workSource);
     } catch (RemoteException ex) {
     }
</code></pre>

<p>}</p>

<p>```</p>

<p>到 AlarmManagerService :</p>

<p>```
 @Override</p>

<pre><code>public void set(int type, long triggerAtTime, long windowLength, long interval,
        PendingIntent operation, WorkSource workSource) {
    if (workSource != null) {
        mContext.enforceCallingPermission(
                android.Manifest.permission.UPDATE_DEVICE_STATS,
                "AlarmManager.set");
    }    

    set(type, triggerAtTime, windowLength, interval, operation, false, workSource);
}
</code></pre>

<p>&ndash;>
 public void set(int type, long triggerAtTime, long windowLength, long interval,</p>

<pre><code>        PendingIntent operation, boolean isStandalone, WorkSource workSource) {
</code></pre>

<p>&hellip;
 setImplLocked(type, triggerAtTime, triggerElapsed, windowLength, maxElapsed,</p>

<pre><code>                interval, operation, isStandalone, true, workSource);
</code></pre>

<p>}</p>

<p>&ndash;></p>

<p> private void setImplLocked(int type, long when, long whenElapsed, long windowLength,</p>

<pre><code>        long maxWhen, long interval, PendingIntent operation, boolean isStandalone,
        boolean doValidate, WorkSource workSource) {
</code></pre>

<p>&hellip;
rescheduleKernelAlarmsLocked();
}</p>

<p>&ndash;></p>

<p>  private void rescheduleKernelAlarmsLocked() {</p>

<pre><code>    // Schedule the next upcoming wakeup alarm.  If there is a deliverable batch
    // prior to that which contains no wakeups, we schedule that as well.
    if (mAlarmBatches.size() &gt; 0) {
        final Batch firstWakeup = findFirstWakeupBatchLocked();
        final Batch firstBatch = mAlarmBatches.get(0);
        if (firstWakeup != null &amp;&amp; mNextWakeup != firstWakeup.start) {
            mNextWakeup = firstWakeup.start;
            setLocked(ELAPSED_REALTIME_WAKEUP, firstWakeup.start);
        }
        if (firstBatch != firstWakeup &amp;&amp; mNextNonWakeup != firstBatch.start) {
            mNextNonWakeup = firstBatch.start;
            setLocked(ELAPSED_REALTIME, firstBatch.start);
        }
    }
}
</code></pre>

<p>&ndash;></p>

<p> private void setLocked(int type, long when)</p>

<pre><code>{
      if (mDescriptor != -1)
    {
        // The kernel never triggers alarms with negative wakeup times
        // so we ensure they are positive.
        long alarmSeconds, alarmNanoseconds;
        if (when &lt; 0) {
            alarmSeconds = 0;
            alarmNanoseconds = 0;
        } else {
            alarmSeconds = when / 1000;
            alarmNanoseconds = (when % 1000) * 1000 * 1000;
        }

        set(mDescriptor, type, alarmSeconds, alarmNanoseconds);
}
</code></pre>

<p>&ndash;>
private native void set(int fd, int type, long seconds, long nanoseconds);
```</p>

<p>native 方法:</p>

<p>```cpp frameworks/base/services/jni/com_android_server_AlarmManagerService.cpp</p>

<p>static void android_server_AlarmManagerService_set(JNIEnv* env, jobject obj, jint fd, jint type, jlong seconds, jlong nanoseconds)
{</p>

<pre><code>struct timespec ts; 
ts.tv_sec = seconds;
ts.tv_nsec = nanoseconds;

int result = ioctl(fd, ANDROID_ALARM_SET(type), &amp;ts);
if (result &lt; 0)
{   
    ALOGE("Unable to set alarm to %lld.%09lld: %s\n", seconds, nanoseconds, strerror(errno));
}   
</code></pre>

<p>}</p>

<p>```
fd 从哪里来的？AlarmManagerService 初始化来的:</p>

<p>``` java frameworks/services/java/com/android/server/AlarmManagerService.java
 public AlarmManagerService(Context context) {</p>

<pre><code>    mContext = context;
    mDescriptor = init();
    mNextWakeup = mNextNonWakeup = 0;
    ...
}
</code></pre>

<p>```</p>

<p>init 是 native 方法:</p>

<p>```cpp frameworks/base/services/jni/com_android_server_AlarmManagerService.cpp
static jint android_server_AlarmManagerService_init(JNIEnv* env, jobject obj)
{</p>

<pre><code>return open("/dev/alarm", O_RDWR);
</code></pre>

<p>}
```</p>

<p>在设下 alarm 之后， AlarmManagerService 启动了一个 AlarmThread 来等待 alarm 的事件。</p>

<p>```java frameworks/services/java/com/android/server/AlarmManagerService.java</p>

<p> private final AlarmThread mWaitThread = new AlarmThread();</p>

<p> public AlarmManagerService(Context context) {</p>

<pre><code>     ...
     if (mDescriptor != -1) {
        mWaitThread.start();
    } else {
        Slog.w(TAG, "Failed to open alarm driver. Falling back to a handler.");
    }
}
</code></pre>

<p>```</p>

<p>这个 AlarmThread 就会循环等待 alarm 事件！</p>

<p>```java frameworks/services/java/com/android/server/AlarmManagerService.java
  private class AlarmThread extends Thread</p>

<pre><code>{
    public AlarmThread()
    {
        super("AlarmManager");
    }

    public void run()
    {
        ArrayList&lt;Alarm&gt; triggerList = new ArrayList&lt;Alarm&gt;();

        while (true)
        {
            int result = waitForAlarm(mDescriptor);
            ...
        }
    }
}
</code></pre>

<p>```</p>

<p>等到设定的时间到了的时候， AlarmManagerService 就会收到消息，发送当初设定的 PendingIntent.</p>

<p>这样就满足了设定特定时间提醒的功能。</p>

<p>对于像钟表这样的程序，就需要一种机制，几乎是时时的告诉，当前是什么时间，而且要每一秒都要更新。这个需求怎么满足呢？</p>

<p>Android 的设计中有一个 Intent 是标识这种时间改变的，但是不是每秒，是每分钟啊 ！！
```java Intent.java</p>

<pre><code>/**  
 * Broadcast Action: The current time has changed.  Sent every
 * minute.  You can &lt;em&gt;not&lt;/em&gt; receive this through components declared
 * in manifests, only by explicitly registering for it with
 * {@link Context#registerReceiver(BroadcastReceiver, IntentFilter)
 * Context.registerReceiver()}.
 *
 * &lt;p class="note"&gt;This is a protected intent that can only be sent
 * by the system.
 */
@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
public static final String ACTION_TIME_TICK = "android.intent.action.TIME_TICK";
</code></pre>

<p>```</p>

<p>你只要注册了这个 Intent , 每分钟开始的时候都会受到这个 Intent。AlarmManagerService 是如何提供这个服务的呢？</p>

<p>在 AlarmManagerService 的构造函数中会创建一个 ClockReceiver， 并在 scheduleTimeTickEvent 中调用native <code>set</code> 方法设置一个一分钟后的时间提醒，设置的 PendingIntent 就是 ACTION_TIME_TICK 这个 Intent。</p>

<p>而且，这个 ClockReceiver 还注册了ACTION_TIME_TICK 的监听。一分钟后它自己也会收到 ACTION_TIME_TICK，收到之后，它又调用了一次 scheduleTimeTickEvent，设定了下一分钟的提醒。如是，每分钟都会可以收到这个提醒了！</p>

<p>```java frameworks/services/java/com/android/server/AlarmManagerService.java
  public AlarmManagerService(Context context) {</p>

<pre><code>    ...

    mTimeTickSender = PendingIntent.getBroadcastAsUser(context, 0,
            new Intent(Intent.ACTION_TIME_TICK).addFlags(
                    Intent.FLAG_RECEIVER_REGISTERED_ONLY
                    | Intent.FLAG_RECEIVER_FOREGROUND), 0,
                    UserHandle.ALL);
    // now that we have initied the driver schedule the alarm
    mClockReceiver= new ClockReceiver();
    mClockReceiver.scheduleTimeTickEvent();
    ...

}
</code></pre>

<p>   class ClockReceiver extends BroadcastReceiver {</p>

<pre><code>    public ClockReceiver() {
        IntentFilter filter = new IntentFilter();
        filter.addAction(Intent.ACTION_TIME_TICK);
        filter.addAction(Intent.ACTION_DATE_CHANGED);
        mContext.registerReceiver(this, filter);
    }
   public void onReceive(Context context, Intent intent) {
        if (intent.getAction().equals(Intent.ACTION_TIME_TICK)) {
            scheduleTimeTickEvent();
    }

  public void scheduleTimeTickEvent() {
        final long currentTime = System.currentTimeMillis();
        final long nextTime = 60000 * ((currentTime / 60000) + 1);

        // Schedule this event for the amount of time that it would take to get to
        // the top of the next minute.
        final long tickEventDelay = nextTime - currentTime;

        final WorkSource workSource = null; // Let system take blame for time tick events.
        set(ELAPSED_REALTIME, SystemClock.elapsedRealtime() + tickEventDelay, 0,
                0, mTimeTickSender, true, workSource);
    }
}
</code></pre>

<p>```</p>

<p>可是这样的话，每秒钟的提醒它肯定满足不了，那么时钟是如何实现秒针的现实的呢？</p>

<p>```java packages/apps/DeskClock/src/com/android/deskclock/AnalogClock.java</p>

<pre><code>protected void onAttachedToWindow() {
 ...
 // tick the seconds
 post(mClockTick);
 ...
}

private final Runnable mClockTick = new Runnable () {

    @Override
    public void run() {
        onTimeChanged();
        invalidate();
        AnalogClock.this.postDelayed(mClockTick, 1000);
    }   
}; 
</code></pre>

<p>```</p>

<p>在创建的时候 post 一个 Runnable， 在 Runnable 中的 run 方法中 又设定了在一秒钟之后，再 post 这个 Runnable。这样每秒钟都会执行 Runnable 一次，进行重新绘制。</p>

<p>DeskClock 中的 widget 插件和应用里面第二个 TAB 中的数字时钟都是使用 <code>TextClock</code>， <code>TextClock</code> 也是监听 <code>ACTION_TIME_TICK</code> 来完成每分钟的更新的。参考代码：</p>

<ul>
<li>frameworks/base/core/java/android/widget/TextClock.java</li>
</ul>


<p>Statusbar 上的 Clock 也是监听 <code>ACTION_TIME_TICK</code> 来完成每分钟的更新的。参考代码:</p>

<ul>
<li>frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/policy/Clock.java</li>
</ul>


<p>Keyguard 上的 Clock 显示也是使用的 <code>TextClock</code> 同上 。</p>

<p>对于分钟这个精度的时间显示都可以使用监听 <code>ACTION_TIME_TICK</code> 的方式来完成。但是收到这个 Intent 的时候并没有将当前的时间传递过来，所以还是需要另外的接口来完成获取当前准确时间的需求。</p>

<p>获取当前 UTC 时间是通过 <code>System.currentTimeMillis()</code> 来完成的。</p>

<p>```java libcore/luni/src/main/java/java/lang/System.java</p>

<pre><code>/** 
 * Returns the current time in milliseconds since January 1, 1970 00:00:00.0 UTC.
 *
 * &lt;p&gt;This method always returns UTC times, regardless of the system's time zone.
 * This is often called "Unix time" or "epoch time".
 * Use a {@link java.text.DateFormat} instance to format this time for display to a human.
 *
 * &lt;p&gt;This method shouldn't be used for measuring timeouts or
 * other elapsed time measurements, as changing the system time can affect
 * the results. Use {@link #nanoTime} for that.
 */
public static native long currentTimeMillis();
</code></pre>

<p>```</p>

<p>为什么定义 1970.1.1 开始呢？因为那大概是Unix诞生的时间。</p>

<p>这个 native 方法调用 <code>gettimeofday</code> 来完成的:</p>

<p>```cpp libcore/luni/src/main/native/java_lang_System.cpp
static jlong System_currentTimeMillis(JNIEnv*, jclass) {</p>

<pre><code>timeval now;
gettimeofday(&amp;now, NULL);
jlong when = now.tv_sec * 1000LL + now.tv_usec / 1000;
return when;
</code></pre>

<p>}
```</p>

<p>在 Linux shell 环境下输入 <code>man gettimeofday</code> 获取更多信息：</p>

<p>```
GETTIMEOFDAY(2)                                      Linux Programmer&rsquo;s Manual                                     GETTIMEOFDAY(2)</p>

<p>NAME</p>

<pre><code>   gettimeofday, settimeofday - get / set time
</code></pre>

<p>SYNOPSIS</p>

<pre><code>   #include &lt;sys/time.h&gt;

   int gettimeofday(struct timeval *tv, struct timezone *tz);
   int settimeofday(const struct timeval *tv, const struct timezone *tz);
</code></pre>

<p>   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):</p>

<pre><code>   settimeofday(): _BSD_SOURCE
</code></pre>

<p>DESCRIPTION</p>

<pre><code>   The  functions  gettimeofday()  and  settimeofday()  can  get and set the time as well as a timezone.  The tv argument is a
   struct timeval (as specified in &lt;sys/time.h&gt;):

       struct timeval {
           time_t      tv_sec;     /* seconds */
           suseconds_t tv_usec;    /* microseconds */
       };

   and gives the number of seconds and microseconds since the Epoch (see time(2)).  The tz argument is a struct timezone:

       struct timezone {
           int tz_minuteswest;     /* minutes west of Greenwich */
           int tz_dsttime;         /* type of DST correction */
       };

   If either tv or tz is NULL, the corresponding structure is not set or returned.
</code></pre>

<p>```</p>

<p>timeval 带有两个成员， <code>tv_sec</code> 保存秒数，<code>tv_usec</code> 保存微秒(1/1000000 秒).可以看到上面 timeval 到毫秒的转化 :</p>

<p><code>
jlong when = now.tv_sec * 1000LL + now.tv_usec / 1000;
</code></p>

<p>gettimeofday的实现是经 libc 进入内核，实际上是一个 system call 。详情参考 kernel 的代码。</p>

<p>关于 libc 和 内核的实现关系，我需要学习后再来讨论，可以参考下 <a href="http://www.win.tue.nl/~aeb/linux/lk/lk-3.html">user space and libc interface</a></p>

<p>获取系统已经运行的时间有几个不同的 API , 都在 SystemClock.java 中:</p>

<ul>
<li>elapsedRealtime ()                //Returns milliseconds since boot, including time spent in sleep.</li>
<li>elapsedRealtimeNanos ()          //Returns nanoseconds since boot, including time spent in sleep.</li>
<li>uptimeMillis ()                  //Returns milliseconds since boot, not counting time spent in deep sleep.</li>
</ul>


<p><code>elapsedRealtime()</code> 和 <code>elapsedRealtimeNanos()</code> 包含系统 sleep 的时间，而 <code>uptimeMillis()</code> 不包含 sleep 的时间。参考 <a href="http://developer.android.com/reference/android/os/SystemClock.html">SystemClock</a></p>

<p><code>elapsedRealtime()</code> api 用的比较多，Android 系统里面 Settings->About phone->Status->Uptime 显示的就是这个时间。Settings->Battery 显示的时间也是用这个时间计算出来的（减去上一次 unplug 的时间）。</p>

<p>来看下 <code>elapsedRealtime</code> 的底层实现：</p>

<p><code>java SystemClock.java
 native public static long elapsedRealtime();
</code>
在 SystemClock 里用的是 native 的方法。</p>

<p>```cpp frameworks/base/core/jni/android_os_SystemClock.cpp
/<em>
 * native public static long elapsedRealtime();
 </em>/
static jlong android_os_SystemClock_elapsedRealtime(JNIEnv* env,</p>

<pre><code>    jobject clazz)
</code></pre>

<p>{</p>

<pre><code>return (jlong)elapsedRealtime();
</code></pre>

<p>}</p>

<p>```</p>

<p>cpp 中调用了libutils 中的方法 <code>elapsedRealtime()</code>.</p>

<p>```cpp system/core/libutils/SystemClock.cpp
/<em>
 * native public static long elapsedRealtime();
 </em>/
int64_t elapsedRealtime()
{</p>

<pre><code>return nanoseconds_to_milliseconds(elapsedRealtimeNano());
</code></pre>

<p>}</p>

<p>&ndash;></p>

<p>/<em>
 * native public static long elapsedRealtimeNano();
 </em>/
int64_t elapsedRealtimeNano()
{
&hellip;</p>

<pre><code>static int s_fd = -1;

if (s_fd == -1) {
    int fd = open("/dev/alarm", O_RDONLY);
    if (android_atomic_cmpxchg(-1, fd, &amp;s_fd)) {
        close(fd);
    }
}

result = ioctl(s_fd,
        ANDROID_ALARM_GET_TIME(ANDROID_ALARM_ELAPSED_REALTIME), &amp;ts);

if (result == 0) {
    timestamp = seconds_to_nanoseconds(ts.tv_sec) + ts.tv_nsec;
    checkTimeStamps(timestamp, &amp;prevTimestamp, &amp;prevMethod, METHOD_IOCTL);
    return timestamp;
}
</code></pre>

<p>&hellip;
}
```</p>

<p>和闹钟的提醒功能相似，<code>elapsedRealtimeNano()</code> 也是通过 <code>/dev/alarm</code> 的 ioctl 来完成的，具体的实现要参看 driver 的代码了。</p>

<p>好了，获取当前时间(UTC)通过 kernel system call 完成， 获取系统运行时间通过 ioctl
<code>/dev/alarm</code> 来完成。</p>

<p>Alarm/Clock 系统还需要提供的一个功能是设置/同步时间。由于手机芯片中缺少一个断电之后能继续维持时间的模块，所以，拔掉电池之后再开机之后时间会出现偏差（如果没有同步或手动设置时间)。</p>

<p>在 Android 系统中， Settings-> Date &amp; Time  &ndash;> 提供了设置时间和同步时间的UI 接口。
Date 和 Time 的设置都是使用 AlarmManagerService 提供的 <code>setTime</code> 接口。</p>

<p>```java AlarmManagerService.java</p>

<pre><code>public void setTime(long millis) {
    mContext.enforceCallingOrSelfPermission(
            "android.permission.SET_TIME",
            "setTime");  //检查 permission

    SystemClock.setCurrentTimeMillis(millis);
}
</code></pre>

<p>```</p>

<p>AlarmManagerService 调用了 SystemClock 的 api <code>setCurrentTimeMillis</code>.</p>

<p>```java SystemClock.java</p>

<pre><code>/** 
 * Sets the current wall time, in milliseconds.  Requires the calling
 * process to have appropriate permissions.
 *
 * @return if the clock was successfully set to the specified time.
 */
native public static boolean setCurrentTimeMillis(long millis);
</code></pre>

<p>```</p>

<p>SystemClock.java 调用了 native 方法</p>

<p>```cpp android_os_SystemClock.cpp
/<em>
 * Set the current time.  This only works when running as root.
 </em>/
static int setCurrentTimeMillis(int64_t millis)
{</p>

<p>&hellip;</p>

<pre><code>fd = open("/dev/alarm", O_RDWR);
</code></pre>

<p>&hellip;</p>

<pre><code>res = ioctl(fd, ANDROID_ALARM_SET_RTC, &amp;ts);
</code></pre>

<p>&hellip;
}
<code>``
android_os_SystemClock.cpp 是直接利用 ioctl</code>/dev/alarm` 调用到 driver 的 alarm 来完成。</p>

<p>同步时间的功能是定期的从 Google 的服务器 2.android.pool.ntp.org (默认配置) 获取时间,刷新的时间间隔有两种，一种长的是 24 h，一种短的是 60s。</p>

<p>参考代码:</p>

<ul>
<li>frameworks/base/services/java/com/android/server/NetworkTimeUpdateService.java</li>
<li>frameworks/base/core/java/android/util/NtpTrustedTime.java</li>
<li>frameworks/base/core/res/res/values/config.xml</li>
</ul>


<p>通过 ioctl <code>/dev/alarm</code> 操组 driver 的 alarm 模块来完成设置时间，通过定期和 Google 服务器 2.android.pool.ntp.org 同步来完成时间的同步。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[android properties data structure]]></title>
    <link href="http://SteveVallay.github.io/blog/2013/12/24/android-properties-data-structure/"/>
    <updated>2013-12-24T13:04:00+08:00</updated>
    <id>http://SteveVallay.github.io/blog/2013/12/24/android-properties-data-structure</id>
    <content type="html"><![CDATA[<p>写文章不应太多拘泥于细节：</p>

<ul>
<li>言简意赅</li>
<li>图胜于文</li>
<li>图文并茂</li>
<li>点到为止</li>
</ul>


<!-- more -->


<p>从 Jelly Bean 到 KitKat 版本， <code>properties</code> 的存储的数据结构还是有些变化的.</p>

<p>实际存储位置： <strong>/dev/__properties__</strong> 文件 (root RW， 其他只能 R)
<code>bash
ls -al /dev/__proper*
-rw-r--r-- root     root        65536 1970-01-14 05:26 __properties__
</code></p>

<p>关于 Jelly Bean（或者以前的)， 直接上张图，比较明了：</p>

<p><img src="/images/blog/prop_struct_jb.png" alt="jb proper data structure" /></p>

<p>先看下相关结构的定义:</p>

<p>```c  system/core/init/property_service.c
typedef struct {</p>

<pre><code>void *data;
size_t size;
int fd; 
</code></pre>

<p>} workspace;</p>

<p>```</p>

<p>```c bionic/libc/bionic/system_properties.c
struct prop_area {</p>

<pre><code>unsigned volatile count;
unsigned volatile serial;  //不知道这个是干什么的?
unsigned magic;
unsigned version;
unsigned reserved[4];
unsigned toc[1];
</code></pre>

<p>};</p>

<p>struct prop_info {</p>

<pre><code>char name[PROP_NAME_MAX];
unsigned volatile serial;
char value[PROP_VALUE_MAX];
</code></pre>

<p>};
```
toc[i] 里面存放的是 property name 的长度 (前 8 位) 和对应 proper_info 对应的地址 (后 24位)。
proper_info 的 serial (前 8 位) 保存的是 property value 的 length。</p>

<p>但是有几个问题:</p>

<ul>
<li>大小是不对的 , Jelly Bean 上大小是 65536, 可以放 495 个 properties.</li>
</ul>


<p>```c system/core/init/properties_service.c
/<em> (8 header words + 495 toc words) = 2012 bytes </em>/
/<em> 2016 bytes header and toc + 495 prop_infos @ 128 bytes = 65376 bytes </em>/</p>

<h1>define PA_COUNT_MAX  495</h1>

<h1>define PA_INFO_START 2016</h1>

<h1>define PA_SIZE       65536</h1>

<p>```</p>

<ul>
<li>share memory 是不对的, 这个图在 init 进程里面没什么问题。但是其他进程访问（读取的时候) 其实是将同样的文件(<strong>/dev/__properties__</strong>) map 了一份到自己的内存空间。所以每个进程的这个结构是自己的，不是共享的。</li>
</ul>


<p>KitKat ：</p>

<p>KK 上总大小是  128*1024</p>

<p>数据结构:
```c bionic/libc/bionic/system_properties.c
struct prop_area {</p>

<pre><code>unsigned bytes_used;
unsigned volatile serial;
unsigned magic;
unsigned version;
unsigned reserved[28];
char data[0];
</code></pre>

<p>};</p>

<p>struct prop_info {</p>

<pre><code>unsigned volatile serial;
char value[PROP_VALUE_MAX];
char name[0];
</code></pre>

<p>};</p>

<p>struct prop_bt {</p>

<pre><code>uint8_t namelen;
uint8_t reserved[3];

prop_off_t prop;

prop_off_t left;
prop_off_t right;

prop_off_t children;

char name[0];
</code></pre>

<p>};</p>

<p>```</p>

<p>Kitkat 上 proper info 的存储已经改为 bTree 了，bytes_used 用来记录存储这些信息所使用的空间。</p>

<p><code>c bionic/libc/bionic/system_properties.c
 * +-----+   children    +----+   children    +--------+
 * |     |--------------&gt;| ro |--------------&gt;| secure |
 * +-----+               +----+               +--------+
 *                       /    \                /   |
 *                 left /      \ right   left /    |  prop   +===========+
 *                     v        v            v     +--------&gt;| ro.secure |
 *                  +-----+   +-----+     +-----+            +-----------+
 *                  | net |   | sys |     | com |            |     1     |
 *                  +-----+   +-----+     +-----+            +===========+
</code></p>

<p>好了， 就到这里吧! 感谢 ～</p>

<p>参考文档: <a href="http://rxwen.blogspot.com/2010/01/android-property-system.html">http://rxwen.blogspot.com/2010/01/android-property-system.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[android system properties dynamic]]></title>
    <link href="http://SteveVallay.github.io/blog/2013/12/23/android-system-properties2/"/>
    <updated>2013-12-23T10:17:00+08:00</updated>
    <id>http://SteveVallay.github.io/blog/2013/12/23/android-system-properties2</id>
    <content type="html"><![CDATA[<p>静态的程序代码和程序运行时的状态，有很大的不同。理解代码，要理解其运行时的样子。</p>

<!--more-->


<p>这一篇主要说说 android property service 的运行时状态。</p>

<p>先来看看这个图大致理解一下:</p>

<p><img src="/images/blog/android_property.png" alt="android-property" /></p>

<p>可以查看下手机的 /dev/__properties__ 文件(Kitkat 4.4) ：</p>

<p>```</p>

<h1>ls -al /dev/<em>*__proper</em></h1>

<p>-rw-r&mdash;r&mdash; root     root        65536 1970-01-12 05:24 <strong>properties</strong>
```</p>

<p>Init 进程，创建 <strong>/dev/__properties__</strong> 文件，map 到内存，然后从 <strong>/default.prop</strong>等文件中加载 properties, 写入 <strong>/dev/__properties__</strong>. 然后启动 property_service , 就是建立一个 <code>property_service</code> 的 socket ，监听这个 socket ，其他进程通过向这个 socket 发送 proper_set 的消息来完成 properties 的设置。</p>

<p>proper_get 是在每个进程在初始化时(libc中) 建立了 <strong>/dev/__properties__</strong>到内存的 map ，得到了可以直接访问的 address，可以直接遍历 properties 的存储空间完成查找.</p>

<p>下面细细到来：</p>

<p>Init 进程，Android 用户空间的第一个进程，内核启动之后会执行这个 init 程序。进入到 init 的main 函数。 在 init.c 的 main 函数里面，初始化 property 相关的存储空间。</p>

<p><strong>system/core/init/init.c</strong></p>

<p><code>c
 property_init();
</code></p>

<p><code>property_init</code> 是调用 property_service.c 的方法。</p>

<p><strong>/system/core/init/property_service.c</strong>
```
 void property_init(void)
 {</p>

<pre><code> init_property_area();
</code></pre>

<p> }</p>

<p>static int init_property_area(void)
{</p>

<pre><code>if (property_area_inited)
    return -1;

if(__system_property_area_init()) //关键这个
    return -1;

if(init_workspace(&amp;pa_workspace, 0))
    return -1;

fcntl(pa_workspace.fd, F_SETFD, FD_CLOEXEC);

property_area_inited = 1;
return 0;
</code></pre>

<p>}
```</p>

<p><code>__system_property_area_init</code> 方法在 <strong>bionic/libc/bionic/system_properties.c</strong></p>

<p>```c
int __system_property_area_init()
{</p>

<pre><code>return map_prop_area_rw();
</code></pre>

<p>}</p>

<p>static int map_prop_area_rw()
{</p>

<pre><code>prop_area *pa;
int fd;
int ret;

/* dev is a tmpfs that we can use to carve a shared workspace
 * out of, so let's do that...
 */
fd = open(property_filename, O_RDWR | O_CREAT | O_NOFOLLOW | O_CLOEXEC |
        O_EXCL, 0444);
if (fd &lt; 0) {
    if (errno == EACCES) {
        /* for consistency with the case where the process has already
         * mapped the page in and segfaults when trying to write to it
         */
        abort();
    }
    return -1;
}

ret = fcntl(fd, F_SETFD, FD_CLOEXEC);
if (ret &lt; 0)
    goto out;

if (ftruncate(fd, PA_SIZE) &lt; 0)
    goto out;

pa_size = PA_SIZE;
pa_data_size = pa_size - sizeof(prop_area);
compat_mode = false;

pa = mmap(NULL, pa_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
if(pa == MAP_FAILED)
    goto out;

memset(pa, 0, pa_size);
pa-&gt;magic = PROP_AREA_MAGIC;
pa-&gt;version = PROP_AREA_VERSION;
/* reserve root node */
pa-&gt;bytes_used = sizeof(prop_bt);

/* plug into the lib property services */
__system_property_area__ = pa;

close(fd);
return 0;
</code></pre>

<p>out:</p>

<pre><code>close(fd);
return -1;
</code></pre>

<p>}</p>

<p>```</p>

<p>首先创建 <strong>/dev/__properties__</strong> ，并且用 <code>mmap</code> 映射到内存.（通过变量<code>__system_property_area__</code> 的共享，完成 property_service 和 libc 中 properties 相关的交互。)</p>

<p>```c</p>

<h1>define PROP_FILENAME &ldquo;/dev/<strong>properties</strong>&rdquo;</h1>

<p>static char property_filename[PATH_MAX] = PROP_FILENAME;</p>

<p> fd = open(property_filename, O_RDWR | O_CREAT | O_NOFOLLOW | O_CLOEXEC |</p>

<pre><code>        O_EXCL, 0444);
</code></pre>

<p>&hellip;</p>

<pre><code>pa = mmap(NULL, pa_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);

/* plug into the lib property services */
__system_property_area__ = pa;
</code></pre>

<p>```</p>

<p>回到 init.c , 加载 boot defults properties：</p>

<p>init.c
<code>c
 property_load_boot_defaults();
</code></p>

<p>property_service.c:
```c</p>

<h1>define PROP_PATH_RAMDISK_DEFAULT  &ldquo;/default.prop&rdquo;</h1>

<p> void property_load_boot_defaults(void)
 {</p>

<pre><code> load_properties_from_file(PROP_PATH_RAMDISK_DEFAULT);
</code></pre>

<p> }
```</p>

<p><code>load_properties_from_file</code> 这个里面就是读取文件，然后 <code>set_property</code>。</p>

<p>回到 init.c , 启动 property service :</p>

<p>init.c:
```c
 queue_builtin_action(property_service_init_action, &ldquo;property_service_init&rdquo;);</p>

<p>static int property_service_init_action(int nargs, char **args)
{</p>

<pre><code>/* read any property files on system or data and
 * fire up the property service.  This must happen
 * after the ro.foo properties are set above so
 * that /data/local.prop cannot interfere with them.
 */
start_property_service();

/* update with vendor-specific property runtime
 * overrides
 */
vendor_load_properties();
return 0;
</code></pre>

<p>}</p>

<p>```</p>

<p>在 <code>start_property_service</code> 中，加载 properties (/system/build.prop, /system/default.prop, /data/property/xxx)，创建 <strong>/dev/socket/property_service</strong> 这个 socket, 并且监听这个 socket 来接受 set property 的消息。</p>

<p>property_service.c:
```c</p>

<p>void start_property_service(void)
{</p>

<pre><code>int fd; 

load_properties_from_file(PROP_PATH_SYSTEM_BUILD);
load_properties_from_file(PROP_PATH_SYSTEM_DEFAULT);
load_override_properties();
/* Read persistent properties after all default values have been loaded. */
load_persistent_properties();

fd = create_socket(PROP_SERVICE_NAME, SOCK_STREAM, 0666, 0, 0); 
if(fd &lt; 0) return;
fcntl(fd, F_SETFD, FD_CLOEXEC);
fcntl(fd, F_SETFL, O_NONBLOCK);

listen(fd, 8); 
property_set_fd = fd; 
</code></pre>

<p>}
```</p>

<p>回到 init.c :</p>

<p>init 进程在 main 函数的最后，进入一个无限循环，等待 <strong>/dev/socket/property_service</strong> 和其他 fd 的事件并处理。</p>

<p>```c</p>

<pre><code>for(;;) {
    int nr, i, timeout = -1;

    execute_one_command();
    restart_processes();

    if (!property_set_fd_init &amp;&amp; get_property_set_fd() &gt; 0) { 
        ufds[fd_count].fd = get_property_set_fd();
        ufds[fd_count].events = POLLIN;
        ufds[fd_count].revents = 0; 
        fd_count++;
        property_set_fd_init = 1; 
    }    
    if (!signal_fd_init &amp;&amp; get_signal_fd() &gt; 0) { 
        ufds[fd_count].fd = get_signal_fd();
        ufds[fd_count].events = POLLIN;
        ufds[fd_count].revents = 0; 
        fd_count++;
        signal_fd_init = 1; 
    }    
    if (!keychord_fd_init &amp;&amp; get_keychord_fd() &gt; 0) { 
        ufds[fd_count].fd = get_keychord_fd();
        ufds[fd_count].events = POLLIN;
        ufds[fd_count].revents = 0; 
        fd_count++;
        keychord_fd_init = 1; 
    }    
    if (process_needs_restart) {
        timeout = (process_needs_restart - gettime()) * 1000;
        if (timeout &lt; 0) 
            timeout = 0; 
    }    

    if (!action_queue_empty() || cur_action)
        timeout = 0;
</code></pre>

<h1>if BOOTCHART</h1>

<pre><code>    if (bootchart_count &gt; 0) {
        if (timeout &lt; 0 || timeout &gt; BOOTCHART_POLLING_MS)
            timeout = BOOTCHART_POLLING_MS;
        if (bootchart_step() &lt; 0 || --bootchart_count == 0) {
            bootchart_finish();
            bootchart_count = 0;
        }
    }
</code></pre>

<h1>endif</h1>

<pre><code>    nr = poll(ufds, fd_count, timeout);
    if (nr &lt;= 0)
        continue;

    for (i = 0; i &lt; fd_count; i++) {
        if (ufds[i].revents == POLLIN) {
            if (ufds[i].fd == get_property_set_fd())
                handle_property_set_fd();                 //关键这里
            else if (ufds[i].fd == get_keychord_fd())
                handle_keychord();
            else if (ufds[i].fd == get_signal_fd())
                handle_signal();
        }
    }
}
</code></pre>

<p>```</p>

<p><code>handler_property_set_fd</code> 里面接收 <code>/dev/socket/property_service</code> 的消息并处理。</p>

<p>property_service.c:</p>

<p>```c
void handle_property_set_fd()
{</p>

<pre><code>prop_msg msg;
int s; 
int r;  
int res;    
struct ucred cr;
struct sockaddr_un addr;
socklen_t addr_size = sizeof(addr);
socklen_t cr_size = sizeof(cr);
char * source_ctx = NULL;

if ((s = accept(property_set_fd, (struct sockaddr *) &amp;addr, &amp;addr_size)) &lt; 0) {
    return;
}   

/* Check socket options here */
if (getsockopt(s, SOL_SOCKET, SO_PEERCRED, &amp;cr, &amp;cr_size) &lt; 0) {
    close(s);
    ERROR("Unable to receive socket options\n");
    return;     
}           

r = TEMP_FAILURE_RETRY(recv(s, &amp;msg, sizeof(msg), 0));
if(r != sizeof(prop_msg)) {
    ERROR("sys_prop: mis-match msg size received: %d expected: %d errno: %d\n",
          r, sizeof(prop_msg), errno);
    close(s);
    return;
}
switch(msg.cmd) {
case PROP_MSG_SETPROP:                              //处理 set proper 请求
    msg.name[PROP_NAME_MAX-1] = 0;
    msg.value[PROP_VALUE_MAX-1] = 0;

    if (!is_legal_property_name(msg.name, strlen(msg.name))) {
        ERROR("sys_prop: illegal property name. Got: \"%s\"\n", msg.name);
        close(s);
        return;
    }

    getpeercon(s, &amp;source_ctx);

    if(memcmp(msg.name,"ctl.",4) == 0) {
        // Keep the old close-socket-early behavior when handling
        // ctl.* properties.
        close(s);
        if (check_control_perms(msg.value, cr.uid, cr.gid, source_ctx)) {
            handle_control_message((char*) msg.name + 4, (char*) msg.value);
        } else {
            ERROR("sys_prop: Unable to %s service ctl [%s] uid:%d gid:%d pid:%d\n",
                    msg.name + 4, msg.value, cr.uid, cr.gid, cr.pid);
        }
    } else {
        if (check_perms(msg.name, cr.uid, cr.gid, source_ctx)) {
            property_set((char*) msg.name, (char*) msg.value);    //设置 prop
        } else {
            ERROR("sys_prop: permission denied uid:%d  name:%s\n",
                  cr.uid, msg.name);
        }

        // Note: bionic's property client code assumes that the
        // property server will not close the socket until *AFTER*
        // the property is written to memory.
        close(s);
    }
    freecon(source_ctx);
    break;

default:
    close(s);
    break;
}
</code></pre>

<p>}
```</p>

<p>在 <code>property_set</code> 之前会 <code>check_perms</code>, 不同的 property_set 需要什么权限呢?</p>

<p>```c
/<em> White list of permissions for setting property services. </em>/
struct {</p>

<pre><code>const char *prefix;
unsigned int uid;
unsigned int gid;
</code></pre>

<p>} property_perms[] = {</p>

<pre><code>{ "net.rmnet0.",      AID_RADIO,    0 },
{ "net.gprs.",        AID_RADIO,    0 },
{ "net.ppp",          AID_RADIO,    0 },
{ "net.qmi",          AID_RADIO,    0 },
{ "net.lte",          AID_RADIO,    0 },
{ "net.cdma",         AID_RADIO,    0 },
{ "ril.",             AID_RADIO,    0 },
{ "gsm.",             AID_RADIO,    0 },
{ "persist.radio",    AID_RADIO,    0 },
{ "net.dns",          AID_RADIO,    0 },
{ "sys.usb.config",   AID_RADIO,    0 },
{ "net.",             AID_SYSTEM,   0 },
{ "dev.",             AID_SYSTEM,   0 },
{ "runtime.",         AID_SYSTEM,   0 },
{ "hw.",              AID_SYSTEM,   0 },
{ "sys.",             AID_SYSTEM,   0 },
{ "sys.powerctl",     AID_SHELL,    0 },
{ "service.",         AID_SYSTEM,   0 },
{ "wlan.",            AID_SYSTEM,   0 },
{ "bluetooth.",       AID_BLUETOOTH,   AID_SYSTEM },
{ "dhcp.",            AID_SYSTEM,   0 },
{ "dhcp.",            AID_DHCP,     0 },
{ "debug.",           AID_SYSTEM,   0 },
{ "debug.",           AID_SHELL,    0 },
{ "log.",             AID_SHELL,    0 },
{ "service.adb.root", AID_SHELL,    0 },
{ "service.adb.tcp.port", AID_SHELL,    0 },
{ "persist.sys.",     AID_SYSTEM,   0 },
{ "persist.service.", AID_SYSTEM,   0 },
{ "persist.security.", AID_SYSTEM,   0 },
{ "persist.service.bdroid.", AID_BLUETOOTH,   0 },
{ "selinux."         , AID_SYSTEM,   0 },
{ NULL, 0, 0 } 
</code></pre>

<p>};
```</p>

<p>接着就 <code>property_set</code>:</p>

<p>先查询有的话，就 <code>__system_property_update</code> , 没有就 <code>__system_property_add</code> ,如果是 <code>persist.</code>的话，要 <code>write_persistent_property</code> 写入到 <strong>/data/property/xxx</strong></p>

<p>```c
int property_set(const char <em>name, const char </em>value)
{</p>

<pre><code>prop_info *pi;
int ret;

size_t namelen = strlen(name);
size_t valuelen = strlen(value);

if (!is_legal_property_name(name, namelen)) return -1; 
if (valuelen &gt;= PROP_VALUE_MAX) return -1; 

pi = (prop_info*) __system_property_find(name);

if(pi != 0) {
    /* ro.* properties may NEVER be modified once set */
    if(!strncmp(name, "ro.", 3)) return -1; 

    __system_property_update(pi, value, valuelen);
} else {
    ret = __system_property_add(name, namelen, value, valuelen);
    if (ret &lt; 0) {
        ERROR("Failed to set '%s'='%s'\n", name, value);
        return ret;
    }   
}   
/* If name starts with "net." treat as a DNS property. */
if (strncmp("net.", name, strlen("net.")) == 0)  {
    if (strcmp("net.change", name) == 0) {
        return 0;
    }   
   /*  
    * The 'net.change' property is a special property used track when any
    * 'net.*' property name is updated. It is _ONLY_ updated here. Its value
    * contains the last updated 'net.*' property.
    */
    property_set("net.change", name);
} else if (persistent_properties_loaded &amp;&amp;
        strncmp("persist.", name, strlen("persist.")) == 0) {
    /*  
     * Don't write properties to disk until after we have read all default properties
     * to prevent them from being overwritten by default values.
     */
    write_persistent_property(name, value);
} else if (strcmp("selinux.reload_policy", name) == 0 &amp;&amp;
           strcmp("1", value) == 0) {
    selinux_reload_policy();
}
property_changed(name, value);
return 0;
</code></pre>

<p>}
```</p>

<p>OK， <code>proper_set</code> 流程先到这里，下面来看看 <code>proper_get</code> . <code>proper_get</code> 直接向下到 libc 的 <code>__system_property_get</code> 的 api.</p>

<p><strong>/bionic/libc/bionic/system_properties.c</strong></p>

<p>```c
int __system_property_get(const char <em>name, char </em>value)
{</p>

<pre><code>const prop_info *pi = __system_property_find(name);

if(pi != 0) {
    return __system_property_read(pi, 0, value);
} else {
    value[0] = 0;
    return 0;
}   
</code></pre>

<p>}
```</p>

<p>这里是调用了 <code>__system_property_find</code> 来查找这个值。在往下看：
```
const prop_info <em>__system_property_find(const char </em>name)
{</p>

<pre><code>if (__predict_false(compat_mode)) {  //貌似没打开 compat_mode 
    return __system_property_find_compat(name);
}
return find_property(root_node(), name, strlen(name), NULL, 0, false); //看这里
</code></pre>

<p>}
```</p>

<p>这里调用 <code>find_property</code> 来访问 <code>root_node()</code>, 什么是 <code>root_node()</code>?</p>

<p>```c
static prop_bt *root_node()
{</p>

<pre><code>return to_prop_obj(0);
</code></pre>

<p>}</p>

<p>static void *to_prop_obj(prop_off_t off)
{</p>

<pre><code>if (off &gt; pa_data_size)
    return NULL;

return __system_property_area__-&gt;data + off;
</code></pre>

<p>}
```</p>

<p>实际上获取 <code>__system_property_area__-&gt;data</code>的地址开始访问。OK, <code>__system_property_area__</code> 是哪里？ 正是 <strong>/dev/<strong>properties</strong></strong> map 到内存的地址。</p>

<p>init.c 进程调用了 system_properties.c 的 <code>__system_property_area_init</code> &ndash;> <code>map_prop_area_rw</code> 在这里：</p>

<p>创建 <code>property_filename</code>(/dev/_-properties__), <code>mmap</code> 到内存， 将地址赋值给 <code>__system_property_area__</code> 。</p>

<p>```c
static int map_prop_area_rw()
{
&hellip;
fd = open(property_filename, O_RDWR | O_CREAT | O_NOFOLLOW | O_CLOEXEC |</p>

<pre><code>        O_EXCL, 0444);
</code></pre>

<p>&hellip;
 pa = mmap(NULL, pa_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);</p>

<p>&hellip;
/<em> plug into the lib property services </em>/</p>

<pre><code>__system_property_area__ = pa;
</code></pre>

<p>&hellip;
}
```</p>

<p>但是，慢着！ 这些都是在 init 进程里面执行的，其他进程调用 <code>__system_property_find</code> 怎么可以直接访问 <code>__system_property_area__</code> ? 难道 其他进程和 init 共享了这个地址，这是不可能的，这个变量怎会传递到 init 的子进程？就算传递了，它们怎么可能访问相同的地址呢？它们可是不同进程啊，各自使用自己独享的内存空间啊！</p>

<p>所以，呵呵！ 其他进程肯定也对 <code>__system_property_area__</code> 进行初始化了！ 在哪里 ？
<strong>/bionic/libc/bionic/libc_init_common.cpp</strong> 中 调用了 <code>__system_properties_init()</code>
<code>c
void __libc_init_common(KernelArgumentBlock&amp; args) {
...
 __system_properties_init();
}
</code></p>

<p><strong>/bionic/libc/bionic/system_properties.c</strong>
```c
int __system_properties_init()
{</p>

<pre><code>return map_prop_area();
</code></pre>

<p>}</p>

<p>static int map_prop_area()
{
 &hellip;
 fd = open(property_filename, O_RDONLY | O_NOFOLLOW | O_CLOEXEC);
 &hellip;
prop_area *pa = mmap(NULL, pa_size, PROT_READ, MAP_SHARED, fd, 0);
&hellip;
 <strong>system_property_area</strong> = pa;
&hellip;
}
```</p>

<p>以 RDONLY 模式打开了 <code>/dev/__properties__</code> 文件，并且 mmap 到内存，将地址赋值给 <code>__system_property_area__</code> ！ 所以，其他进程可以直接访问 <code>__system_property_area__</code> 不过这个肯定和 init 进程里那个是不同的！！</p>

<p>OK！ 结束，下一篇讲讲 property 存储区的数据结构 ！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android System Properties]]></title>
    <link href="http://SteveVallay.github.io/blog/2013/12/13/android-systemproperties/"/>
    <updated>2013-12-13T23:41:00+08:00</updated>
    <id>http://SteveVallay.github.io/blog/2013/12/13/android-systemproperties</id>
    <content type="html"><![CDATA[<p>&mdash;直朝那个方向走，或许真的能到达那个地方。o(∩∩)o&hellip;哈哈</p>

<p>Property system 是 Android 系统中一个重要的 Feature，它以一个 service 的形式来管理系统的配置和状态，每个 property 都是一个 key/value 组，key 和 value 都是字符串。</p>

<p>这些配置和状态信息在 Android 的所有进程中都可以读取、设置和修改，所以 Property system 成了 Android 系统中控制全局配置的一种常用手段。你可以预置 system propterties 作为系统的初始设置，也可以运行是设置和改变 system properties 的值。</p>

<p>因此，system properties 经常作为一些特定 Feature 的控制开关，运行时根据 properties 的值来区分打开/关闭某个 Feature.由于在所有进程都可以访问，也可以用来在 Android 的不同进程间进行简单信息协调，Java 和 native 都不受限制。</p>

<p>下面我们就按自上而下的顺序看看 Android 的这个 Properties system 的实现（Kitkat 4.4)。</p>

<!--more-->


<p><img src="/images/blog/property-call-stack.png" alt="properties call stack" /></p>

<h4>Java 层</h4>

<p><strong>frameworks/base/core/java/android/os/SystemProperties.java</strong></p>

<p>java 层的接口在 <em>SysstemProperties.java</em> 这个文件中,经常使用的接口有以下几个：</p>

<p>```java
/<em>Get the value for the given key.</em>/
public static String get(String key)
public static String get(String key, String def)
public static int getInt(String key, int def)
public static long getLong(String key, long def）
public static boolean getBoolean(String key, boolean def)</p>

<p>/<em>Set the value for the given key.</em>/
public static void set(String key, String val)
```</p>

<p>简单来说就是 <code>get</code> 和 <code>set</code> 方法，都是静态方法，直接使用 SystemProperties.get/set 就可以访问。不过 SystemProperties 是一个 <em>hide</em> 的类，不在 SDK 的标准 API 中，也就意味着，在基于 SDK 的 app 开发中不能直接使用（可以尝试反射 ^_^)。</p>

<h4>Framework 层</h4>

<p>进到这几个方法的里面来看，就会发现，它们都是调用了 native 方法:</p>

<p>```java</p>

<pre><code>private static native String native_get(String key);
private static native String native_get(String key, String def);
private static native int native_get_int(String key, int def);
private static native long native_get_long(String key, long def);
private static native boolean native_get_boolean(String key, boolean def);
private static native void native_set(String key, String def);
</code></pre>

<p>```
这些 native 方法在哪里定义和实现呢 ？</p>

<p><strong>frameworks/base/core/jni/android_os_SystemProperties.cpp</strong>(android framework 的 native 实现在 <strong>/frameworks/base/core/jni</strong> 下面可以看到)</p>

<p>从代码可以知道，这一层只是调用底层接口，提供 JNI 支持。</p>

<p>```c++
static jstring SystemProperties_getSS(JNIEnv *env, jobject clazz,</p>

<pre><code>                                  jstring keyJ, jstring defJ);
</code></pre>

<p>static void SystemProperties_set(JNIEnv *env, jobject clazz,</p>

<pre><code>                                  jstring keyJ, jstring valJ);
</code></pre>

<p>&hellip;
```</p>

<p><strong>get/set</strong> 方法内部调用了两个底层接口：</p>

<p><code>c++
property_set(key,value);
property_get(key, buf,default);
</code>
这两个接口定义在哪里呢？</p>

<p>```c</p>

<h1>include &ldquo;cutils/properties.h&rdquo;</h1>

<p>```</p>

<p>这个.h 文件在 <strong>system/core/include/cutils/properties.h</strong></p>

<p>在这个文件中可以看到这两个函数的声明。</p>

<p><code>c
int property_get(const char *key, char *value, const char *default_value);
int property_set(const char *key, const char *value);
</code>
这两个函数的实现在哪里呢？ 在 <strong>properties.c</strong> 中</p>

<p><strong>system/core/libcutils/properties.c</strong></p>

<p>在这个文件中我们可以看到根据不同的宏定义有几种不同的实现。</p>

<p>```c</p>

<h1>ifdef HAVE_LIBC_SYSTEM_PROPERTIES</h1>

<h1>define <em>REALLY_INCLUDE_SYS__SYSTEM_PROPERTIES_H</em></h1>

<h1>include &lt;sys/_system_properties.h></h1>

<p>&hellip;</p>

<h1>elif defined(HAVE_SYSTEM_PROPERTY_SERVER)</h1>

<p>&hellip;</p>

<h1>else</h1>

<p>/<em> SUPER-cheesy place-holder implementation for Win32 </em>/</p>

<h1>include &lt;cutils/threads.h></h1>

<p>&hellip;
```
在实际的手机运行环境中，property system 使用的是第一种的实现，第二种是模拟器环境的实现，第三种嘛? 嘿嘿 ~</p>

<p>我们重点来看第一种好了，因为第一种是实际的手机运行环境。在这种实现中，同样是调用了两个类似的 <code>api</code>  <strong>__system_property_set</strong> 和 <strong>__system_property_get</strong> （在 <strong>sys/_system_properties.h</strong> 中声明的).</p>

<p>```c</p>

<h1>ifdef HAVE_LIBC_SYSTEM_PROPERTIES</h1>

<h1>define <em>REALLY_INCLUDE_SYS__SYSTEM_PROPERTIES_H</em></h1>

<h1>include &lt;sys/_system_properties.h></h1>

<p>int property_set(const char <em>key, const char </em>value)
{</p>

<pre><code>return __system_property_set(key, value);
</code></pre>

<p>}</p>

<p>int property_get(const char <em>key, char </em>value, const char *default_value)
{</p>

<pre><code>int len;

len = __system_property_get(key, value);
if(len &gt; 0) {
    return len;
}

if(default_value) {
    len = strlen(default_value);
    memcpy(value, default_value, len + 1);
}
return len;
</code></pre>

<p>}
```
先看一下 <strong>sys/_system_properties.h</strong> 中定义的几个基本结构.
<strong>bionic/libc/include/sys/_system_properties.h</strong></p>

<p>```</p>

<h1>define PROP_SERVICE_NAME &ldquo;property_service&rdquo;</h1>

<h1>define TOC_NAME_LEN(toc)       ((toc) >> 24)</h1>

<h1>define TOC_TO_INFO(area, toc)  ((prop_info<em>) (((char</em>) area) + ((toc) &amp; 0xFFFFFF)))</h1>

<p>struct prop_area {</p>

<pre><code>unsigned volatile count;
unsigned volatile serial;
unsigned magic;
unsigned version;
unsigned reserved[4];
unsigned toc[1];
</code></pre>

<p>};</p>

<p>struct prop_info {</p>

<pre><code>char name[PROP_NAME_MAX];
unsigned volatile serial;
char value[PROP_VALUE_MAX];
</code></pre>

<p>};</p>

<p>struct prop_msg
{</p>

<pre><code>unsigned cmd;
char name[PROP_NAME_MAX];
char value[PROP_VALUE_MAX];
</code></pre>

<p>};</p>

<h1>define PROP_MSG_SETPROP 1</h1>

<h1>define PROP_PATH_RAMDISK_DEFAULT  &ldquo;/default.prop&rdquo;</h1>

<h1>define PROP_PATH_SYSTEM_BUILD     &ldquo;/system/build.prop&rdquo;</h1>

<h1>define PROP_PATH_SYSTEM_DEFAULT   &ldquo;/system/default.prop&rdquo;</h1>

<h1>define PROP_PATH_LOCAL_OVERRIDE   &ldquo;/data/local.prop&rdquo;</h1>

<p>```</p>

<p>这两个 <code>api</code> 又在哪里实现呢？ ^_^
查看 <strong>bionic/libc/bionic/system_properties.c</strong></p>

<p>```c
static const char property_service_socket[] = &ldquo;/dev/socket/&rdquo; PROP_SERVICE_NAME;</p>

<p>int __system_property_get(const char <em>name, char </em>value)
{</p>

<pre><code>const prop_info *pi = __system_property_find(name);

if(pi != 0) {
    return __system_property_read(pi, 0, value);
} else {
    value[0] = 0;
    return 0;
}
</code></pre>

<p>}</p>

<p>int __system_property_set(const char <em>key, const char </em>value)
{</p>

<pre><code>int err;
int tries = 0;
int update_seen = 0;
prop_msg msg;

if(key == 0) return -1;
if(value == 0) value = "";
if(strlen(key) &gt;= PROP_NAME_MAX) return -1;
if(strlen(value) &gt;= PROP_VALUE_MAX) return -1;

memset(&amp;msg, 0, sizeof msg);
msg.cmd = PROP_MSG_SETPROP;
strlcpy(msg.name, key, sizeof msg.name);
strlcpy(msg.value, value, sizeof msg.value);

err = send_prop_msg(&amp;msg);
if(err &lt; 0) {
    return err;
}

return 0;
</code></pre>

<p>}</p>

<p>```</p>

<p>的确在这里找到了 <strong>__system_property_get</strong> 和 <strong>__system_property_set</strong> ,这两个函数的实现有包含了 <strong>__system_property_find</strong> <strong>__system_property_read</strong> 和 <strong>send_prop_msg</strong>
```
const prop_info <em>__system_property_find(const char </em>name)
{</p>

<pre><code>prop_area *pa = __system_property_area__;
unsigned count = pa-&gt;count;
unsigned *toc = pa-&gt;toc;
unsigned len = strlen(name);
prop_info *pi;

while(count--) {
    unsigned entry = *toc++;
    if(TOC_NAME_LEN(entry) != len) continue;

    pi = TOC_TO_INFO(pa, entry);
    if(memcmp(name, pi-&gt;name, len)) continue;

    return pi;
}

return 0;
</code></pre>

<p>}</p>

<p>int __system_property_read(const prop_info <em>pi, char </em>name, char *value)
{</p>

<pre><code>unsigned serial, len;

for(;;) {
    serial = pi-&gt;serial;
    while(SERIAL_DIRTY(serial)) {
        __futex_wait((volatile void *)&amp;pi-&gt;serial, serial, 0);
        serial = pi-&gt;serial;
    }
    len = SERIAL_VALUE_LEN(serial);
    memcpy(value, pi-&gt;value, len + 1);
    if(serial == pi-&gt;serial) {
        if(name != 0) {
            strcpy(name, pi-&gt;name);
        }
        return len;
    }
}
</code></pre>

<p>}</p>

<p>static int send_prop_msg(prop_msg *msg)
{</p>

<pre><code>struct pollfd pollfds[1];
struct sockaddr_un addr;
socklen_t alen;
size_t namelen;
int s;
int r;
int result = -1;

s = socket(AF_LOCAL, SOCK_STREAM, 0);
if(s &lt; 0) {
    return result;
}

memset(&amp;addr, 0, sizeof(addr));
namelen = strlen(property_service_socket);
strlcpy(addr.sun_path, property_service_socket, sizeof addr.sun_path);
addr.sun_family = AF_LOCAL;
alen = namelen + offsetof(struct sockaddr_un, sun_path) + 1;

if(TEMP_FAILURE_RETRY(connect(s, (struct sockaddr *) &amp;addr, alen)) &lt; 0) {
    close(s);
    return result;
}

r = TEMP_FAILURE_RETRY(send(s, msg, sizeof(prop_msg), 0));
if(r == sizeof(prop_msg)) {
    // We successfully wrote to the property server but now we
    // wait for the property server to finish its work.  It
    // acknowledges its completion by closing the socket so we
    // poll here (on nothing), waiting for the socket to close.
    // If you 'adb shell setprop foo bar' you'll see the POLLHUP
    // once the socket closes.  Out of paranoia we cap our poll
    // at 250 ms.
    pollfds[0].fd = s;
    pollfds[0].events = 0;
    r = TEMP_FAILURE_RETRY(poll(pollfds, 1, 250 /* ms */));
    if (r == 1 &amp;&amp; (pollfds[0].revents &amp; POLLHUP) != 0) {
        result = 0;
    } else {
        // Ignore the timeout and treat it like a success anyway.
        // The init process is single-threaded and its property
        // service is sometimes slow to respond (perhaps it's off
        // starting a child process or something) and thus this
        // times out and the caller thinks it failed, even though
        // it's still getting around to it.  So we fake it here,
        // mostly for ctl.* properties, but we do try and wait 250
        // ms so callers who do read-after-write can reliably see
        // what they've written.  Most of the time.
        // TODO: fix the system properties design.
        result = 0;
    }
}

close(s);
return result;
</code></pre>

<p>}</p>

<p>```
看到这里，我们大概知道 get 是从一个 prop_info 的结构提中读取，而 set 的则是向 <strong>property_service_socket(&ldquo;/dev/socket/property_service&rdquo;)</strong> 发送数据。但不免又有很多疑问，property 存储在哪，数据结构是怎样的？proper_set 发送socket 数据是谁来接收和处理的？ property system 是如何启动的？</p>

<p>好吧，我们先来总结一下 Android system properties 相关的目录和文件吧。</p>

<p>Java 层：</p>

<ul>
<li>frameworks/base/core/java/android/os/SystemProperties.java</li>
</ul>


<p><code>java
/**
 * Gives access to the system properties store.  The system properties
 * store contains a list of string key-value pairs.
 *
 * {@hide}
 */
</code></p>

<p>native 层：</p>

<p>Android framework 的 native 实现，或者成为 runtime 都是在 <strong>frameworks/base/core/jni</strong> 目录下。</p>

<p>和 properties 相关的文件：
&ndash; frameworks/base/core/jni/android_os_SystemProperties.cpp</p>

<p>```c</p>

<h1>include &ldquo;cutils/properties.h&rdquo;</h1>

<p>```</p>

<p>cutils:</p>

<p><strong>system</strong> 目录，这个目录有什么用呢 ?</p>

<blockquote><p>System &ndash; source code files for the core Android system. That is the minimal Linux system that is started before the Dalvik VM and any java based services are enabled. This includes the source code for the init process and the default init.rc script that provide the dynamic configuration of the platform.</p></blockquote>

<ul>
<li>system/core/libcutils/properties.c  //包含了 _system_properties.h</li>
<li>system/core/include/cutils/properties.h //properties.c 的对外接口 被 jni 包含.</li>
<li>system/core/init/property_service.h  //property_service 的对外接口</li>
<li>system/core/init/property_service.c  //</li>
<li>system/core/init/init.c</li>
</ul>


<p>libc:</p>

<p><strong>Bionic</strong> 这个目录又是干什么的呢？</p>

<blockquote><p>Bionic &ndash; the C-runtime for Android. Note that Android is not using glibc like most Linux distributions. Instead the c-library is called bionic and is based mostly on BSD-derived sources. In this folder you will find the source for the c-library, math and other core runtime libraries.</p></blockquote>

<ul>
<li>bionic/libc/include/sys/_system_properties.h //包含了下面的 system_properties.h</li>
<li>bionic/libc/include/sys/system_properties.h //下面的system_properties.c 对外接口声明</li>
<li>/libc/bionic/system_properties.c</li>
</ul>

]]></content>
  </entry>
  
</feed>
