<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: android | Zhibin's blog]]></title>
  <link href="http://SteveVallay.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://SteveVallay.github.io/"/>
  <updated>2013-12-24T09:41:22+08:00</updated>
  <id>http://SteveVallay.github.io/</id>
  <author>
    <name><![CDATA[zhibin]]></name>
    <email><![CDATA[zhibinwang.q@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[android_system_properties 2]]></title>
    <link href="http://SteveVallay.github.io/blog/2013/12/23/android-system-properties2/"/>
    <updated>2013-12-23T10:17:00+08:00</updated>
    <id>http://SteveVallay.github.io/blog/2013/12/23/android-system-properties2</id>
    <content type="html"><![CDATA[<p>静态的程序代码和程序运行时的状态，有很大的不同。理解代码，要理解其运行时的样子。</p>

<!--more-->


<p>这一篇主要说说 android property service 的运行时状态。</p>

<p>先来看看这个图大致理解一下:</p>

<p><img src="/images/blog/android_property.png" alt="android-property" /></p>

<p>可以查看下手机的 /dev/<strong>properties</strong> 文件(Kitkat 4.4) ：</p>

<p>```</p>

<h1>ls -al /dev/<em>*__proper</em></h1>

<p>-rw-r&mdash;r&mdash; root     root        65536 1970-01-12 05:24 <strong>properties</strong>
```</p>

<p>Init 进程，创建 <strong>/dev/<strong>properties</strong></strong> 文件，map 到内存，然后从 <strong>/default.prop</strong>等文件中加载 properties, 写入 <strong>/dev/<strong>properties</strong></strong>. 然后启动 property_service , 就是建立一个 <code>property_service</code> 的 socket ，监听这个 socket ，其他进程通过向这个 socket 发送 proper_set 的消息来完成 properties 的设置。</p>

<p>proper_get 是在每个进程在初始化时(libc中) 建立了 <strong>/dev/<strong>properties</strong></strong>到内存的 map ，得到了可以直接访问的 address，可以直接遍历 properties 的存储空间完成查找.</p>

<p>下面细细到来：</p>

<p>Init 进程，Android 用户空间的第一个进程，内核启动之后会执行这个 init 程序。进入到 init 的main 函数。 在 init.c 的 main 函数里面，初始化 property 相关的存储空间。</p>

<p><strong>system/core/init/init.c</strong></p>

<p><code>c
 property_init();
</code></p>

<p><code>property_init</code> 是调用 property_service.c 的方法。</p>

<p><strong>/system/core/init/property_service.c</strong>
```
 void property_init(void)
 {</p>

<pre><code> init_property_area();
</code></pre>

<p> }</p>

<p>static int init_property_area(void)
{</p>

<pre><code>if (property_area_inited)
    return -1;

if(__system_property_area_init()) //关键这个
    return -1;

if(init_workspace(&amp;pa_workspace, 0))
    return -1;

fcntl(pa_workspace.fd, F_SETFD, FD_CLOEXEC);

property_area_inited = 1;
return 0;
</code></pre>

<p>}
```</p>

<p><code>__system_property_area_init</code> 方法在 <strong>bionic/libc/bionic/system_properties.c</strong></p>

<p>```c
int __system_property_area_init()
{</p>

<pre><code>return map_prop_area_rw();
</code></pre>

<p>}</p>

<p>static int map_prop_area_rw()
{</p>

<pre><code>prop_area *pa;
int fd;
int ret;

/* dev is a tmpfs that we can use to carve a shared workspace
 * out of, so let's do that...
 */
fd = open(property_filename, O_RDWR | O_CREAT | O_NOFOLLOW | O_CLOEXEC |
        O_EXCL, 0444);
if (fd &lt; 0) {
    if (errno == EACCES) {
        /* for consistency with the case where the process has already
         * mapped the page in and segfaults when trying to write to it
         */
        abort();
    }
    return -1;
}

ret = fcntl(fd, F_SETFD, FD_CLOEXEC);
if (ret &lt; 0)
    goto out;

if (ftruncate(fd, PA_SIZE) &lt; 0)
    goto out;

pa_size = PA_SIZE;
pa_data_size = pa_size - sizeof(prop_area);
compat_mode = false;

pa = mmap(NULL, pa_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
if(pa == MAP_FAILED)
    goto out;

memset(pa, 0, pa_size);
pa-&gt;magic = PROP_AREA_MAGIC;
pa-&gt;version = PROP_AREA_VERSION;
/* reserve root node */
pa-&gt;bytes_used = sizeof(prop_bt);

/* plug into the lib property services */
__system_property_area__ = pa;

close(fd);
return 0;
</code></pre>

<p>out:</p>

<pre><code>close(fd);
return -1;
</code></pre>

<p>}</p>

<p>```</p>

<p>首先创建 <strong>/dev/<strong>properties</strong></strong> ，并且用 <code>mmap</code> 映射到内存.（通过变量<code>__system_property_area__</code> 的共享，完成 property_service 和 libc 中 properties 相关的交互。)</p>

<p>```c</p>

<h1>define PROP_FILENAME &ldquo;/dev/<strong>properties</strong>&rdquo;</h1>

<p>static char property_filename[PATH_MAX] = PROP_FILENAME;</p>

<p> fd = open(property_filename, O_RDWR | O_CREAT | O_NOFOLLOW | O_CLOEXEC |</p>

<pre><code>        O_EXCL, 0444);
</code></pre>

<p>&hellip;</p>

<pre><code>pa = mmap(NULL, pa_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);

/* plug into the lib property services */
__system_property_area__ = pa;
</code></pre>

<p>```</p>

<p>回到 init.c , 加载 boot defults properties：</p>

<p>init.c
<code>c
 property_load_boot_defaults();
</code></p>

<p>property_service.c:
```c</p>

<h1>define PROP_PATH_RAMDISK_DEFAULT  &ldquo;/default.prop&rdquo;</h1>

<p> void property_load_boot_defaults(void)
 {</p>

<pre><code> load_properties_from_file(PROP_PATH_RAMDISK_DEFAULT);
</code></pre>

<p> }
```</p>

<p><code>load_properties_from_file</code> 这个里面就是读取文件，然后 <code>set_property</code>。</p>

<p>回到 init.c , 启动 property service :</p>

<p>init.c:
```c
 queue_builtin_action(property_service_init_action, &ldquo;property_service_init&rdquo;);</p>

<p>static int property_service_init_action(int nargs, char **args)
{</p>

<pre><code>/* read any property files on system or data and
 * fire up the property service.  This must happen
 * after the ro.foo properties are set above so
 * that /data/local.prop cannot interfere with them.
 */
start_property_service();

/* update with vendor-specific property runtime
 * overrides
 */
vendor_load_properties();
return 0;
</code></pre>

<p>}</p>

<p>```</p>

<p>在 <code>start_property_service</code> 中，加载 properties (/system/build.prop, /system/default.prop, /data/property/xxx)，创建 <strong>/dev/socket/property_service</strong> 这个 socket, 并且监听这个 socket 来接受 set property 的消息。</p>

<p>property_service.c:
```c</p>

<p>void start_property_service(void)
{</p>

<pre><code>int fd; 

load_properties_from_file(PROP_PATH_SYSTEM_BUILD);
load_properties_from_file(PROP_PATH_SYSTEM_DEFAULT);
load_override_properties();
/* Read persistent properties after all default values have been loaded. */
load_persistent_properties();

fd = create_socket(PROP_SERVICE_NAME, SOCK_STREAM, 0666, 0, 0); 
if(fd &lt; 0) return;
fcntl(fd, F_SETFD, FD_CLOEXEC);
fcntl(fd, F_SETFL, O_NONBLOCK);

listen(fd, 8); 
property_set_fd = fd; 
</code></pre>

<p>}
```</p>

<p>回到 init.c :</p>

<p>init 进程在 main 函数的最后，进入一个无限循环，等待 <strong>/dev/socket/property_service</strong> 和其他 fd 的事件并处理。</p>

<p>```c</p>

<pre><code>for(;;) {
    int nr, i, timeout = -1;

    execute_one_command();
    restart_processes();

    if (!property_set_fd_init &amp;&amp; get_property_set_fd() &gt; 0) { 
        ufds[fd_count].fd = get_property_set_fd();
        ufds[fd_count].events = POLLIN;
        ufds[fd_count].revents = 0; 
        fd_count++;
        property_set_fd_init = 1; 
    }    
    if (!signal_fd_init &amp;&amp; get_signal_fd() &gt; 0) { 
        ufds[fd_count].fd = get_signal_fd();
        ufds[fd_count].events = POLLIN;
        ufds[fd_count].revents = 0; 
        fd_count++;
        signal_fd_init = 1; 
    }    
    if (!keychord_fd_init &amp;&amp; get_keychord_fd() &gt; 0) { 
        ufds[fd_count].fd = get_keychord_fd();
        ufds[fd_count].events = POLLIN;
        ufds[fd_count].revents = 0; 
        fd_count++;
        keychord_fd_init = 1; 
    }    
    if (process_needs_restart) {
        timeout = (process_needs_restart - gettime()) * 1000;
        if (timeout &lt; 0) 
            timeout = 0; 
    }    

    if (!action_queue_empty() || cur_action)
        timeout = 0;
</code></pre>

<h1>if BOOTCHART</h1>

<pre><code>    if (bootchart_count &gt; 0) {
        if (timeout &lt; 0 || timeout &gt; BOOTCHART_POLLING_MS)
            timeout = BOOTCHART_POLLING_MS;
        if (bootchart_step() &lt; 0 || --bootchart_count == 0) {
            bootchart_finish();
            bootchart_count = 0;
        }
    }
</code></pre>

<h1>endif</h1>

<pre><code>    nr = poll(ufds, fd_count, timeout);
    if (nr &lt;= 0)
        continue;

    for (i = 0; i &lt; fd_count; i++) {
        if (ufds[i].revents == POLLIN) {
            if (ufds[i].fd == get_property_set_fd())
                handle_property_set_fd();                 //关键这里
            else if (ufds[i].fd == get_keychord_fd())
                handle_keychord();
            else if (ufds[i].fd == get_signal_fd())
                handle_signal();
        }
    }
}
</code></pre>

<p>```</p>

<p><code>handler_property_set_fd</code> 里面接收 <code>/dev/socket/property_service</code> 的消息并处理。</p>

<p>property_service.c:</p>

<p>```c
void handle_property_set_fd()
{</p>

<pre><code>prop_msg msg;
int s; 
int r;  
int res;    
struct ucred cr;
struct sockaddr_un addr;
socklen_t addr_size = sizeof(addr);
socklen_t cr_size = sizeof(cr);
char * source_ctx = NULL;

if ((s = accept(property_set_fd, (struct sockaddr *) &amp;addr, &amp;addr_size)) &lt; 0) {
    return;
}   

/* Check socket options here */
if (getsockopt(s, SOL_SOCKET, SO_PEERCRED, &amp;cr, &amp;cr_size) &lt; 0) {
    close(s);
    ERROR("Unable to receive socket options\n");
    return;     
}           

r = TEMP_FAILURE_RETRY(recv(s, &amp;msg, sizeof(msg), 0));
if(r != sizeof(prop_msg)) {
    ERROR("sys_prop: mis-match msg size received: %d expected: %d errno: %d\n",
          r, sizeof(prop_msg), errno);
    close(s);
    return;
}
switch(msg.cmd) {
case PROP_MSG_SETPROP:                              //处理 set proper 请求
    msg.name[PROP_NAME_MAX-1] = 0;
    msg.value[PROP_VALUE_MAX-1] = 0;

    if (!is_legal_property_name(msg.name, strlen(msg.name))) {
        ERROR("sys_prop: illegal property name. Got: \"%s\"\n", msg.name);
        close(s);
        return;
    }

    getpeercon(s, &amp;source_ctx);

    if(memcmp(msg.name,"ctl.",4) == 0) {
        // Keep the old close-socket-early behavior when handling
        // ctl.* properties.
        close(s);
        if (check_control_perms(msg.value, cr.uid, cr.gid, source_ctx)) {
            handle_control_message((char*) msg.name + 4, (char*) msg.value);
        } else {
            ERROR("sys_prop: Unable to %s service ctl [%s] uid:%d gid:%d pid:%d\n",
                    msg.name + 4, msg.value, cr.uid, cr.gid, cr.pid);
        }
    } else {
        if (check_perms(msg.name, cr.uid, cr.gid, source_ctx)) {
            property_set((char*) msg.name, (char*) msg.value);    //设置 prop
        } else {
            ERROR("sys_prop: permission denied uid:%d  name:%s\n",
                  cr.uid, msg.name);
        }

        // Note: bionic's property client code assumes that the
        // property server will not close the socket until *AFTER*
        // the property is written to memory.
        close(s);
    }
    freecon(source_ctx);
    break;

default:
    close(s);
    break;
}
</code></pre>

<p>}
```</p>

<p>在 <code>property_set</code> 之前会 <code>check_perms</code>, 不同的 property_set 需要什么权限呢?</p>

<p>```c
/<em> White list of permissions for setting property services. </em>/
struct {</p>

<pre><code>const char *prefix;
unsigned int uid;
unsigned int gid;
</code></pre>

<p>} property_perms[] = {</p>

<pre><code>{ "net.rmnet0.",      AID_RADIO,    0 },
{ "net.gprs.",        AID_RADIO,    0 },
{ "net.ppp",          AID_RADIO,    0 },
{ "net.qmi",          AID_RADIO,    0 },
{ "net.lte",          AID_RADIO,    0 },
{ "net.cdma",         AID_RADIO,    0 },
{ "ril.",             AID_RADIO,    0 },
{ "gsm.",             AID_RADIO,    0 },
{ "persist.radio",    AID_RADIO,    0 },
{ "net.dns",          AID_RADIO,    0 },
{ "sys.usb.config",   AID_RADIO,    0 },
{ "net.",             AID_SYSTEM,   0 },
{ "dev.",             AID_SYSTEM,   0 },
{ "runtime.",         AID_SYSTEM,   0 },
{ "hw.",              AID_SYSTEM,   0 },
{ "sys.",             AID_SYSTEM,   0 },
{ "sys.powerctl",     AID_SHELL,    0 },
{ "service.",         AID_SYSTEM,   0 },
{ "wlan.",            AID_SYSTEM,   0 },
{ "bluetooth.",       AID_BLUETOOTH,   AID_SYSTEM },
{ "dhcp.",            AID_SYSTEM,   0 },
{ "dhcp.",            AID_DHCP,     0 },
{ "debug.",           AID_SYSTEM,   0 },
{ "debug.",           AID_SHELL,    0 },
{ "log.",             AID_SHELL,    0 },
{ "service.adb.root", AID_SHELL,    0 },
{ "service.adb.tcp.port", AID_SHELL,    0 },
{ "persist.sys.",     AID_SYSTEM,   0 },
{ "persist.service.", AID_SYSTEM,   0 },
{ "persist.security.", AID_SYSTEM,   0 },
{ "persist.service.bdroid.", AID_BLUETOOTH,   0 },
{ "selinux."         , AID_SYSTEM,   0 },
{ NULL, 0, 0 } 
</code></pre>

<p>};
```</p>

<p>接着就 <code>property_set</code>:</p>

<p>先查询有的话，就 <code>__system_property_update</code> , 没有就 <code>__system_property_add</code> ,如果是 <code>persist.</code>的话，要 <code>write_persistent_property</code> 写入到 <strong>/data/property/xxx</strong></p>

<p>```c
int property_set(const char <em>name, const char </em>value)
{</p>

<pre><code>prop_info *pi;
int ret;

size_t namelen = strlen(name);
size_t valuelen = strlen(value);

if (!is_legal_property_name(name, namelen)) return -1; 
if (valuelen &gt;= PROP_VALUE_MAX) return -1; 

pi = (prop_info*) __system_property_find(name);

if(pi != 0) {
    /* ro.* properties may NEVER be modified once set */
    if(!strncmp(name, "ro.", 3)) return -1; 

    __system_property_update(pi, value, valuelen);
} else {
    ret = __system_property_add(name, namelen, value, valuelen);
    if (ret &lt; 0) {
        ERROR("Failed to set '%s'='%s'\n", name, value);
        return ret;
    }   
}   
/* If name starts with "net." treat as a DNS property. */
if (strncmp("net.", name, strlen("net.")) == 0)  {
    if (strcmp("net.change", name) == 0) {
        return 0;
    }   
   /*  
    * The 'net.change' property is a special property used track when any
    * 'net.*' property name is updated. It is _ONLY_ updated here. Its value
    * contains the last updated 'net.*' property.
    */
    property_set("net.change", name);
} else if (persistent_properties_loaded &amp;&amp;
        strncmp("persist.", name, strlen("persist.")) == 0) {
    /*  
     * Don't write properties to disk until after we have read all default properties
     * to prevent them from being overwritten by default values.
     */
    write_persistent_property(name, value);
} else if (strcmp("selinux.reload_policy", name) == 0 &amp;&amp;
           strcmp("1", value) == 0) {
    selinux_reload_policy();
}
property_changed(name, value);
return 0;
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[android_System_Properties]]></title>
    <link href="http://SteveVallay.github.io/blog/2013/12/13/android-systemproperties/"/>
    <updated>2013-12-13T23:41:00+08:00</updated>
    <id>http://SteveVallay.github.io/blog/2013/12/13/android-systemproperties</id>
    <content type="html"><![CDATA[<p>&mdash;直朝那个方向走，或许真的能到达那个地方。o(∩∩)o&hellip;哈哈</p>

<h3>Android SystemProperties</h3>

<p>Property system 是 Android 系统中一个重要的 Feature，它以一个 service 的形式来管理系统的配置和状态，每个 property 都是一个 key/value 组，key 和 value 都是字符串。</p>

<p>这些配置和状态信息在 Android 的所有进程中都可以读取、设置和修改，所以 Property system 成了 Android 系统中控制全局配置的一种常用手段。你可以预置 system propterties 作为系统的初始设置，也可以运行是设置和改变 system properties 的值。</p>

<p>因此，system properties 经常作为一些特定 Feature 的控制开关，运行时根据 properties 的值来区分打开/关闭某个 Feature.由于在所有进程都可以访问，也可以用来在 Android 的不同进程间进行简单信息协调，Java 和 native 都不受限制。</p>

<p>下面我们就按自上而下的顺序看看 Android 的这个 Properties system 的实现（Kitkat 4.4)。</p>

<!--more-->


<h4>Java 层</h4>

<p><strong>frameworks/base/core/java/android/os/SystemProperties.java</strong></p>

<p>java 层的接口在 <em>SysstemProperties.java</em> 这个文件中,经常使用的接口有以下几个：</p>

<p>```java
/<em>Get the value for the given key.</em>/
public static String get(String key)
public static String get(String key, String def)
public static int getInt(String key, int def)
public static long getLong(String key, long def）
public static boolean getBoolean(String key, boolean def)</p>

<p>/<em>Set the value for the given key.</em>/
public static void set(String key, String val)
```</p>

<p>简单来说就是 <code>get</code> 和 <code>set</code> 方法，都是静态方法，直接使用 SystemProperties.get/set 就可以访问。不过 SystemProperties 是一个 <em>hide</em> 的类，不在 SDK 的标准 API 中，也就意味着，在基于 SDK 的 app 开发中不能直接使用（可以尝试反射 ^_^)。</p>

<h4>Framework 层</h4>

<p>进到这几个方法的里面来看，就会发现，它们都是调用了 native 方法:</p>

<p>```java</p>

<pre><code>private static native String native_get(String key);
private static native String native_get(String key, String def);
private static native int native_get_int(String key, int def);
private static native long native_get_long(String key, long def);
private static native boolean native_get_boolean(String key, boolean def);
private static native void native_set(String key, String def);
</code></pre>

<p>```
这些 native 方法在哪里定义和实现呢 ？</p>

<p><strong>frameworks/base/core/jni/android_os_SystemProperties.cpp</strong>(android framework 的 native 实现在 <strong>/frameworks/base/core/jni</strong> 下面可以看到)</p>

<p>从代码可以知道，这一层只是调用底层接口，提供 JNI 支持。</p>

<p>```c++
static jstring SystemProperties_getSS(JNIEnv *env, jobject clazz,</p>

<pre><code>                                  jstring keyJ, jstring defJ);
</code></pre>

<p>static void SystemProperties_set(JNIEnv *env, jobject clazz,</p>

<pre><code>                                  jstring keyJ, jstring valJ);
</code></pre>

<p>&hellip;
```</p>

<p><strong>get/set</strong> 方法内部调用了两个底层接口：</p>

<p><code>c++
property_set(key,value);
property_get(key, buf,default);
</code>
这两个接口定义在哪里呢？</p>

<p>```c</p>

<h1>include &ldquo;cutils/properties.h&rdquo;</h1>

<p>```</p>

<p>这个.h 文件在 <strong>system/core/include/cutils/properties.h</strong></p>

<p>在这个文件中可以看到这两个函数的声明。</p>

<p><code>c
int property_get(const char *key, char *value, const char *default_value);
int property_set(const char *key, const char *value);
</code>
这两个函数的实现在哪里呢？ 在 <strong>properties.c</strong> 中</p>

<p><strong>system/core/libcutils/properties.c</strong></p>

<p>在这个文件中我们可以看到根据不同的宏定义有几种不同的实现。</p>

<p>```c</p>

<h1>ifdef HAVE_LIBC_SYSTEM_PROPERTIES</h1>

<h1>define <em>REALLY_INCLUDE_SYS__SYSTEM_PROPERTIES_H</em></h1>

<h1>include &lt;sys/_system_properties.h></h1>

<p>&hellip;</p>

<h1>elif defined(HAVE_SYSTEM_PROPERTY_SERVER)</h1>

<p>&hellip;</p>

<h1>else</h1>

<p>/<em> SUPER-cheesy place-holder implementation for Win32 </em>/</p>

<h1>include &lt;cutils/threads.h></h1>

<p>&hellip;
```
在实际的手机运行环境中，property system 使用的是第一种的实现，第二种是模拟器环境的实现，第三种嘛? 嘿嘿 ~</p>

<p>我们重点来看第一种好了，因为第一种是实际的手机运行环境。在这种实现中，同样是调用了两个类似的 <code>api</code>  <strong>__system_property_set</strong> 和 <strong>__system_property_get</strong> （在 <strong>sys/_system_properties.h</strong> 中声明的).</p>

<p>```c</p>

<h1>ifdef HAVE_LIBC_SYSTEM_PROPERTIES</h1>

<h1>define <em>REALLY_INCLUDE_SYS__SYSTEM_PROPERTIES_H</em></h1>

<h1>include &lt;sys/_system_properties.h></h1>

<p>int property_set(const char <em>key, const char </em>value)
{</p>

<pre><code>return __system_property_set(key, value);
</code></pre>

<p>}</p>

<p>int property_get(const char <em>key, char </em>value, const char *default_value)
{</p>

<pre><code>int len;

len = __system_property_get(key, value);
if(len &gt; 0) {
    return len;
}

if(default_value) {
    len = strlen(default_value);
    memcpy(value, default_value, len + 1);
}
return len;
</code></pre>

<p>}
```
先看一下 <strong>sys/_system_properties.h</strong> 中定义的几个基本结构.
<strong>bionic/libc/include/sys/_system_properties.h</strong></p>

<p>```</p>

<h1>define PROP_SERVICE_NAME &ldquo;property_service&rdquo;</h1>

<h1>define TOC_NAME_LEN(toc)       ((toc) >> 24)</h1>

<h1>define TOC_TO_INFO(area, toc)  ((prop_info<em>) (((char</em>) area) + ((toc) &amp; 0xFFFFFF)))</h1>

<p>struct prop_area {</p>

<pre><code>unsigned volatile count;
unsigned volatile serial;
unsigned magic;
unsigned version;
unsigned reserved[4];
unsigned toc[1];
</code></pre>

<p>};</p>

<p>struct prop_info {</p>

<pre><code>char name[PROP_NAME_MAX];
unsigned volatile serial;
char value[PROP_VALUE_MAX];
</code></pre>

<p>};</p>

<p>struct prop_msg
{</p>

<pre><code>unsigned cmd;
char name[PROP_NAME_MAX];
char value[PROP_VALUE_MAX];
</code></pre>

<p>};</p>

<h1>define PROP_MSG_SETPROP 1</h1>

<h1>define PROP_PATH_RAMDISK_DEFAULT  &ldquo;/default.prop&rdquo;</h1>

<h1>define PROP_PATH_SYSTEM_BUILD     &ldquo;/system/build.prop&rdquo;</h1>

<h1>define PROP_PATH_SYSTEM_DEFAULT   &ldquo;/system/default.prop&rdquo;</h1>

<h1>define PROP_PATH_LOCAL_OVERRIDE   &ldquo;/data/local.prop&rdquo;</h1>

<p>```</p>

<p>这两个 <code>api</code> 又在哪里实现呢？ ^_^
查看 <strong>bionic/libc/bionic/system_properties.c</strong></p>

<p>```c
static const char property_service_socket[] = &ldquo;/dev/socket/&rdquo; PROP_SERVICE_NAME;</p>

<p>int __system_property_get(const char <em>name, char </em>value)
{</p>

<pre><code>const prop_info *pi = __system_property_find(name);

if(pi != 0) {
    return __system_property_read(pi, 0, value);
} else {
    value[0] = 0;
    return 0;
}
</code></pre>

<p>}</p>

<p>int __system_property_set(const char <em>key, const char </em>value)
{</p>

<pre><code>int err;
int tries = 0;
int update_seen = 0;
prop_msg msg;

if(key == 0) return -1;
if(value == 0) value = "";
if(strlen(key) &gt;= PROP_NAME_MAX) return -1;
if(strlen(value) &gt;= PROP_VALUE_MAX) return -1;

memset(&amp;msg, 0, sizeof msg);
msg.cmd = PROP_MSG_SETPROP;
strlcpy(msg.name, key, sizeof msg.name);
strlcpy(msg.value, value, sizeof msg.value);

err = send_prop_msg(&amp;msg);
if(err &lt; 0) {
    return err;
}

return 0;
</code></pre>

<p>}</p>

<p>```</p>

<p>的确在这里找到了 <strong>__system_property_get</strong> 和 <strong>__system_property_set</strong> ,这两个函数的实现有包含了 <strong>__system_property_find</strong> <strong>__system_property_read</strong> 和 <strong>send_prop_msg</strong>
```
const prop_info <em>__system_property_find(const char </em>name)
{</p>

<pre><code>prop_area *pa = __system_property_area__;
unsigned count = pa-&gt;count;
unsigned *toc = pa-&gt;toc;
unsigned len = strlen(name);
prop_info *pi;

while(count--) {
    unsigned entry = *toc++;
    if(TOC_NAME_LEN(entry) != len) continue;

    pi = TOC_TO_INFO(pa, entry);
    if(memcmp(name, pi-&gt;name, len)) continue;

    return pi;
}

return 0;
</code></pre>

<p>}</p>

<p>int __system_property_read(const prop_info <em>pi, char </em>name, char *value)
{</p>

<pre><code>unsigned serial, len;

for(;;) {
    serial = pi-&gt;serial;
    while(SERIAL_DIRTY(serial)) {
        __futex_wait((volatile void *)&amp;pi-&gt;serial, serial, 0);
        serial = pi-&gt;serial;
    }
    len = SERIAL_VALUE_LEN(serial);
    memcpy(value, pi-&gt;value, len + 1);
    if(serial == pi-&gt;serial) {
        if(name != 0) {
            strcpy(name, pi-&gt;name);
        }
        return len;
    }
}
</code></pre>

<p>}</p>

<p>static int send_prop_msg(prop_msg *msg)
{</p>

<pre><code>struct pollfd pollfds[1];
struct sockaddr_un addr;
socklen_t alen;
size_t namelen;
int s;
int r;
int result = -1;

s = socket(AF_LOCAL, SOCK_STREAM, 0);
if(s &lt; 0) {
    return result;
}

memset(&amp;addr, 0, sizeof(addr));
namelen = strlen(property_service_socket);
strlcpy(addr.sun_path, property_service_socket, sizeof addr.sun_path);
addr.sun_family = AF_LOCAL;
alen = namelen + offsetof(struct sockaddr_un, sun_path) + 1;

if(TEMP_FAILURE_RETRY(connect(s, (struct sockaddr *) &amp;addr, alen)) &lt; 0) {
    close(s);
    return result;
}

r = TEMP_FAILURE_RETRY(send(s, msg, sizeof(prop_msg), 0));
if(r == sizeof(prop_msg)) {
    // We successfully wrote to the property server but now we
    // wait for the property server to finish its work.  It
    // acknowledges its completion by closing the socket so we
    // poll here (on nothing), waiting for the socket to close.
    // If you 'adb shell setprop foo bar' you'll see the POLLHUP
    // once the socket closes.  Out of paranoia we cap our poll
    // at 250 ms.
    pollfds[0].fd = s;
    pollfds[0].events = 0;
    r = TEMP_FAILURE_RETRY(poll(pollfds, 1, 250 /* ms */));
    if (r == 1 &amp;&amp; (pollfds[0].revents &amp; POLLHUP) != 0) {
        result = 0;
    } else {
        // Ignore the timeout and treat it like a success anyway.
        // The init process is single-threaded and its property
        // service is sometimes slow to respond (perhaps it's off
        // starting a child process or something) and thus this
        // times out and the caller thinks it failed, even though
        // it's still getting around to it.  So we fake it here,
        // mostly for ctl.* properties, but we do try and wait 250
        // ms so callers who do read-after-write can reliably see
        // what they've written.  Most of the time.
        // TODO: fix the system properties design.
        result = 0;
    }
}

close(s);
return result;
</code></pre>

<p>}</p>

<p>```
看到这里，我们大概知道 get 是从一个 prop_info 的结构提中读取，而 set 的则是向 <strong>property_service_socket(&ldquo;/dev/socket/property_service&rdquo;)</strong> 发送数据。但不免又有很多疑问，property 存储在哪，数据结构是怎样的？proper_set 发送socket 数据是谁来接收和处理的？ property system 是如何启动的？</p>

<p>好吧，我们先来总结一下 Android system properties 相关的目录和文件吧。</p>

<p>Java 层：</p>

<ul>
<li>frameworks/base/core/java/android/os/SystemProperties.java</li>
</ul>


<p><code>java
/**
 * Gives access to the system properties store.  The system properties
 * store contains a list of string key-value pairs.
 *
 * {@hide}
 */
</code></p>

<p>native 层：</p>

<p>Android framework 的 native 实现，或者成为 runtime 都是在 <strong>frameworks/base/core/jni</strong> 目录下。</p>

<p>和 properties 相关的文件：
&ndash; frameworks/base/core/jni/android_os_SystemProperties.cpp</p>

<p>```c</p>

<h1>include &ldquo;cutils/properties.h&rdquo;</h1>

<p>```</p>

<p>cutils:</p>

<p><strong>system</strong> 目录，这个目录有什么用呢 ?</p>

<blockquote><p>System &ndash; source code files for the core Android system. That is the minimal Linux system that is started before the Dalvik VM and any java based services are enabled. This includes the source code for the init process and the default init.rc script that provide the dynamic configuration of the platform.</p></blockquote>

<ul>
<li>system/core/libcutils/properties.c  //包含了 _system_properties.h</li>
<li>system/core/include/cutils/properties.h //properties.c 的对外接口 被 jni 包含.</li>
<li>system/core/init/property_service.h  //property_service 的对外接口</li>
<li>system/core/init/property_service.c  //</li>
<li>system/core/init/init.c</li>
</ul>


<p>libc:</p>

<p><strong>Bionic</strong> 这个目录又是干什么的呢？</p>

<blockquote><p>Bionic &ndash; the C-runtime for Android. Note that Android is not using glibc like most Linux distributions. Instead the c-library is called bionic and is based mostly on BSD-derived sources. In this folder you will find the source for the c-library, math and other core runtime libraries.</p></blockquote>

<ul>
<li>bionic/libc/include/sys/_system_properties.h //包含了下面的 system_properties.h</li>
<li>bionic/libc/include/sys/system_properties.h //下面的system_properties.c 对外接口声明</li>
<li>/libc/bionic/system_properties.c</li>
</ul>

]]></content>
  </entry>
  
</feed>
