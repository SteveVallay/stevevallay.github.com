<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: android | Zhibin's blog]]></title>
  <link href="http://SteveVallay.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://SteveVallay.github.io/"/>
  <updated>2013-12-16T23:59:44+08:00</updated>
  <id>http://SteveVallay.github.io/</id>
  <author>
    <name><![CDATA[zhibin]]></name>
    <email><![CDATA[zhibinwang.q@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[android_System_Properties]]></title>
    <link href="http://SteveVallay.github.io/blog/2013/12/13/android-systemproperties/"/>
    <updated>2013-12-13T23:41:00+08:00</updated>
    <id>http://SteveVallay.github.io/blog/2013/12/13/android-systemproperties</id>
    <content type="html"><![CDATA[<p>&mdash;直朝那个方向走，或许真的能到达那个地方。o(∩∩)o&hellip;哈哈</p>

<h3>Android SystemProperties</h3>

<p>Property system 是 Android 系统中一个重要的 Feature，它以一个 service 的形式来管理系统的配置和状态，每个 property 都是一个 key/value 组，key 和 value 都是字符串。</p>

<p>这些配置和状态信息在 Android 的所有进程中都可以读取、设置和修改，所以 Property system 成了 Android 系统中控制全局配置的一种常用手段。你可以预置 system propterties 作为系统的初始设置，也可以运行是设置和改变 system properties 的值。</p>

<p>因此，system properties 经常作为一些特定 Feature 的控制开关，运行时根据 properties 的值来区分打开/关闭某个 Feature.由于在所有进程都可以访问，也可以用来在 Android 的不同进程间进行简单信息协调，Java 和 native 都不受限制。</p>

<p>下面我们就按自上而下的顺序看看 Android 的这个 Properties system 的实现。</p>

<!--more-->


<h4>Java 层</h4>

<p><strong>frameworks/base/core/java/android/os/SystemProperties.java</strong></p>

<p>java 层的接口在 <em>SysstemProperties.java</em> 这个文件中,经常使用的接口有以下几个：</p>

<p>```java
/<em>Get the value for the given key.</em>/
public static String get(String key)
public static String get(String key, String def)
public static int getInt(String key, int def)
public static long getLong(String key, long def）
public static boolean getBoolean(String key, boolean def)</p>

<p>/<em>Set the value for the given key.</em>/
public static void set(String key, String val)
```</p>

<p>简单来说就是 <code>get</code> 和 <code>set</code> 方法，都是静态方法，直接使用 SystemProperties.get/set 就可以访问。不过 SystemProperties 是一个 <em>hide</em> 的类，不在 SDK 的标准 API 中，也就意味着，在基于 SDK 的 app 开发中不能直接使用（可以尝试反射 ^_^)。</p>

<h4>Framework 层</h4>

<p>进到这几个方法的里面来看，就会发现，它们都是调用了 native 方法:</p>

<p>```java</p>

<pre><code>private static native String native_get(String key);
private static native String native_get(String key, String def);
private static native int native_get_int(String key, int def);
private static native long native_get_long(String key, long def);
private static native boolean native_get_boolean(String key, boolean def);
private static native void native_set(String key, String def);
</code></pre>

<p>```
这些 native 方法在哪里定义和实现呢 ？</p>

<p><strong>frameworks/base/core/jni/android_os_SystemProperties.cpp</strong>(android framework 的 native 实现在 <strong>/frameworks/base/core/jni</strong> 下面可以看到)</p>

<p>从代码可以知道，这一层只是调用底层接口，提供 JNI 支持。</p>

<p>```c++
static jstring SystemProperties_getSS(JNIEnv *env, jobject clazz,</p>

<pre><code>                                  jstring keyJ, jstring defJ);
</code></pre>

<p>static void SystemProperties_set(JNIEnv *env, jobject clazz,</p>

<pre><code>                                  jstring keyJ, jstring valJ);
</code></pre>

<p>&hellip;
```</p>

<p><strong>get/set</strong> 方法内部调用了两个底层接口：</p>

<p><code>c++
property_set(key,value);
property_get(key, buf,default);
</code>
这两个接口定义在哪里呢？</p>

<p>```c</p>

<h1>include &ldquo;cutils/properties.h&rdquo;</h1>

<p>```</p>

<p>这个.h 文件在 <strong>system/core/include/cutils/properties.h</strong></p>

<p>在这个文件中可以看到这两个函数的声明。</p>

<p><code>c
int property_get(const char *key, char *value, const char *default_value);
int property_set(const char *key, const char *value);
</code>
这两个函数的实现在哪里呢？ 在 <strong>properties.c</strong> 中</p>

<p><strong>system/core/libcutils/properties.c</strong></p>

<p>在这个文件中我们可以看到根据不同的宏定义有几种不同的实现。</p>

<p>```c</p>

<h1>ifdef HAVE_LIBC_SYSTEM_PROPERTIES</h1>

<h1>define <em>REALLY_INCLUDE_SYS__SYSTEM_PROPERTIES_H</em></h1>

<h1>include &lt;sys/_system_properties.h></h1>

<p>&hellip;</p>

<h1>elif defined(HAVE_SYSTEM_PROPERTY_SERVER)</h1>

<p>&hellip;</p>

<h1>else</h1>

<p>/<em> SUPER-cheesy place-holder implementation for Win32 </em>/</p>

<h1>include &lt;cutils/threads.h></h1>

<p>&hellip;
```
在实际的手机运行环境中，property system 使用的是第一种的实现，第二种是模拟器环境的实现，第三种嘛? 嘿嘿 ~</p>

<p>我们重点来看第一种好了，因为第一种是实际的手机运行环境。在这种实现中，同样是调用了两个类似的 <code>api</code>  <strong>__system_property_set</strong> 和 <strong>__system_property_get</strong> （在 <strong>sys/_system_properties.h</strong> 中声明的).</p>

<p>```c</p>

<h1>ifdef HAVE_LIBC_SYSTEM_PROPERTIES</h1>

<h1>define <em>REALLY_INCLUDE_SYS__SYSTEM_PROPERTIES_H</em></h1>

<h1>include &lt;sys/_system_properties.h></h1>

<p>int property_set(const char <em>key, const char </em>value)
{</p>

<pre><code>return __system_property_set(key, value);
</code></pre>

<p>}</p>

<p>int property_get(const char <em>key, char </em>value, const char *default_value)
{</p>

<pre><code>int len;

len = __system_property_get(key, value);
if(len &gt; 0) {
    return len;
}

if(default_value) {
    len = strlen(default_value);
    memcpy(value, default_value, len + 1);
}
return len;
</code></pre>

<p>}
```
先看一下 <strong>sys/_system_properties.h</strong> 中定义的几个基本结构.
<strong>bionic/libc/include/sys/_system_properties.h</strong></p>

<p>```</p>

<h1>define PROP_SERVICE_NAME &ldquo;property_service&rdquo;</h1>

<h1>define TOC_NAME_LEN(toc)       ((toc) >> 24)</h1>

<h1>define TOC_TO_INFO(area, toc)  ((prop_info<em>) (((char</em>) area) + ((toc) &amp; 0xFFFFFF)))</h1>

<p>struct prop_area {</p>

<pre><code>unsigned volatile count;
unsigned volatile serial;
unsigned magic;
unsigned version;
unsigned reserved[4];
unsigned toc[1];
</code></pre>

<p>};</p>

<p>struct prop_info {</p>

<pre><code>char name[PROP_NAME_MAX];
unsigned volatile serial;
char value[PROP_VALUE_MAX];
</code></pre>

<p>};</p>

<p>struct prop_msg
{</p>

<pre><code>unsigned cmd;
char name[PROP_NAME_MAX];
char value[PROP_VALUE_MAX];
</code></pre>

<p>};</p>

<h1>define PROP_MSG_SETPROP 1</h1>

<h1>define PROP_PATH_RAMDISK_DEFAULT  &ldquo;/default.prop&rdquo;</h1>

<h1>define PROP_PATH_SYSTEM_BUILD     &ldquo;/system/build.prop&rdquo;</h1>

<h1>define PROP_PATH_SYSTEM_DEFAULT   &ldquo;/system/default.prop&rdquo;</h1>

<h1>define PROP_PATH_LOCAL_OVERRIDE   &ldquo;/data/local.prop&rdquo;</h1>

<p>```</p>

<p>这两个 <code>api</code> 又在哪里实现呢？ ^_^
查看 <strong>bionic/libc/bionic/system_properties.c</strong></p>

<p>```c
static const char property_service_socket[] = &ldquo;/dev/socket/&rdquo; PROP_SERVICE_NAME;</p>

<p>int __system_property_get(const char <em>name, char </em>value)
{</p>

<pre><code>const prop_info *pi = __system_property_find(name);

if(pi != 0) {
    return __system_property_read(pi, 0, value);
} else {
    value[0] = 0;
    return 0;
}
</code></pre>

<p>}</p>

<p>int __system_property_set(const char <em>key, const char </em>value)
{</p>

<pre><code>int err;
int tries = 0;
int update_seen = 0;
prop_msg msg;

if(key == 0) return -1;
if(value == 0) value = "";
if(strlen(key) &gt;= PROP_NAME_MAX) return -1;
if(strlen(value) &gt;= PROP_VALUE_MAX) return -1;

memset(&amp;msg, 0, sizeof msg);
msg.cmd = PROP_MSG_SETPROP;
strlcpy(msg.name, key, sizeof msg.name);
strlcpy(msg.value, value, sizeof msg.value);

err = send_prop_msg(&amp;msg);
if(err &lt; 0) {
    return err;
}

return 0;
</code></pre>

<p>}</p>

<p>```</p>

<p>的确在这里找到了 <strong>__system_property_get</strong> 和 <strong>__system_property_set</strong> ,这两个函数的实现有包含了 <strong>__system_property_find</strong> <strong>__system_property_read</strong> 和 <strong>send_prop_msg</strong>
```
const prop_info <em>__system_property_find(const char </em>name)
{</p>

<pre><code>prop_area *pa = __system_property_area__;
unsigned count = pa-&gt;count;
unsigned *toc = pa-&gt;toc;
unsigned len = strlen(name);
prop_info *pi;

while(count--) {
    unsigned entry = *toc++;
    if(TOC_NAME_LEN(entry) != len) continue;

    pi = TOC_TO_INFO(pa, entry);
    if(memcmp(name, pi-&gt;name, len)) continue;

    return pi;
}

return 0;
</code></pre>

<p>}</p>

<p>int __system_property_read(const prop_info <em>pi, char </em>name, char *value)
{</p>

<pre><code>unsigned serial, len;

for(;;) {
    serial = pi-&gt;serial;
    while(SERIAL_DIRTY(serial)) {
        __futex_wait((volatile void *)&amp;pi-&gt;serial, serial, 0);
        serial = pi-&gt;serial;
    }
    len = SERIAL_VALUE_LEN(serial);
    memcpy(value, pi-&gt;value, len + 1);
    if(serial == pi-&gt;serial) {
        if(name != 0) {
            strcpy(name, pi-&gt;name);
        }
        return len;
    }
}
</code></pre>

<p>}</p>

<p>static int send_prop_msg(prop_msg *msg)
{</p>

<pre><code>struct pollfd pollfds[1];
struct sockaddr_un addr;
socklen_t alen;
size_t namelen;
int s;
int r;
int result = -1;

s = socket(AF_LOCAL, SOCK_STREAM, 0);
if(s &lt; 0) {
    return result;
}

memset(&amp;addr, 0, sizeof(addr));
namelen = strlen(property_service_socket);
strlcpy(addr.sun_path, property_service_socket, sizeof addr.sun_path);
addr.sun_family = AF_LOCAL;
alen = namelen + offsetof(struct sockaddr_un, sun_path) + 1;

if(TEMP_FAILURE_RETRY(connect(s, (struct sockaddr *) &amp;addr, alen)) &lt; 0) {
    close(s);
    return result;
}

r = TEMP_FAILURE_RETRY(send(s, msg, sizeof(prop_msg), 0));
if(r == sizeof(prop_msg)) {
    // We successfully wrote to the property server but now we
    // wait for the property server to finish its work.  It
    // acknowledges its completion by closing the socket so we
    // poll here (on nothing), waiting for the socket to close.
    // If you 'adb shell setprop foo bar' you'll see the POLLHUP
    // once the socket closes.  Out of paranoia we cap our poll
    // at 250 ms.
    pollfds[0].fd = s;
    pollfds[0].events = 0;
    r = TEMP_FAILURE_RETRY(poll(pollfds, 1, 250 /* ms */));
    if (r == 1 &amp;&amp; (pollfds[0].revents &amp; POLLHUP) != 0) {
        result = 0;
    } else {
        // Ignore the timeout and treat it like a success anyway.
        // The init process is single-threaded and its property
        // service is sometimes slow to respond (perhaps it's off
        // starting a child process or something) and thus this
        // times out and the caller thinks it failed, even though
        // it's still getting around to it.  So we fake it here,
        // mostly for ctl.* properties, but we do try and wait 250
        // ms so callers who do read-after-write can reliably see
        // what they've written.  Most of the time.
        // TODO: fix the system properties design.
        result = 0;
    }
}

close(s);
return result;
</code></pre>

<p>}</p>

<p>```
看到这里，我们大概知道 get 是从一个 prop_info 的结构提中读取，而 set 的则是向 <strong>property_service_socket(&ldquo;/dev/socket/property_service&rdquo;)</strong> 发送数据。但不免又有很多疑问，property 存储在哪，数据结构是怎样的？proper_set 发送socket 数据是谁来接收和处理的？ property system 是如何启动的？</p>
]]></content>
  </entry>
  
</feed>
