<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: android | Zhibin's blog]]></title>
  <link href="http://SteveVallay.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://SteveVallay.github.io/"/>
  <updated>2014-05-22T17:44:17+08:00</updated>
  <id>http://SteveVallay.github.io/</id>
  <author>
    <name><![CDATA[zhibin]]></name>
    <email><![CDATA[zhibinwang.q@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android 启动流程]]></title>
    <link href="http://SteveVallay.github.io/blog/2014/01/09/android-start-process/"/>
    <updated>2014-01-09T14:23:00+08:00</updated>
    <id>http://SteveVallay.github.io/blog/2014/01/09/android-start-process</id>
    <content type="html"><![CDATA[<p>保持你的好奇心和创造力。</p>

<!--more-->


<p>早就好奇， Android 启动的流程是怎样的，正好有时间好好看一下。</p>

<p>在追溯代码之前，先让我们提出几个问题，Andorid 启动过程中需要完成什么任务？然后，站在设计者的角度，想一想，如果是你来设计，你会怎么做？</p>

<ol>
<li>系统服务什么形式存在？如何启动？</li>
<li>系统服务如何为应用提供服务？</li>
<li>应用如何被启动，应用之间如何交互？</li>
<li>应用如何安装/升级？</li>
<li>权限如何控制？</li>
</ol>


<p>暂时想到这些问题，没有细节到具体的模块(如 Telephony,Multimedia 等).下面，来揭开 Android 启动之谜.</p>

<h2>Power 键  到 User Space</h2>

<p>按下 Power 键的时候，系统加电，触发 bootloader (代码见 bootable/),bootloader 载入内存，bootloader 引导 kernel, kernel 启动，kernel 启动用户空间的 init 进程。</p>

<p>这部分还不是很熟悉，这里不做详解。:&ndash;)</p>

<h2>Init 进程</h2>

<p>init 进程是内核启动后调用的第一个用户空间的程序，从 init 开始，系统开始进入用户空间。</p>

<p>init 是一个二进制文件，代码在: <strong>system/core/init/init.c</strong></p>

<p>打开 init.c （kitkat)，找到 <code>main</code> 函数,来看看 init 主要做了哪些工作（&hellip;表示省略部分代码)：</p>

<p>```c system/core/init/init.c
int main(int argc, char **argv)
{
&hellip;</p>

<pre><code>/*清除 umask*/
umask(0);

/*创建目录，挂载文件系统*/
mkdir("/dev", 0755);
mkdir("/proc", 0755);
mkdir("/sys", 0755);

mount("tmpfs", "/dev", "tmpfs", MS_NOSUID, "mode=0755");
mkdir("/dev/pts", 0755);
mkdir("/dev/socket", 0755);
mount("devpts", "/dev/pts", "devpts", 0, NULL);
mount("proc", "/proc", "proc", 0, NULL);
mount("sysfs", "/sys", "sysfs", 0, NULL);

/*猜猜这句是干什么？很有意思 哈哈！*/
close(open("/dev/.booting", O_WRONLY | O_CREAT, 0000));

/*打开 /dev/null 并将 0,1,2 重定向到 /dev/null*/
open_devnull_stdio();

klog_init();
/*初始化 property 详见[android properties][101]*/
property_init();
get_hardware_name(hardware, &amp;revision);

process_kernel_cmdline();

/*selinux 相关*/
union selinux_callback cb;
cb.func_log = klog_write;
selinux_set_callback(SELINUX_CB_LOG, cb);

cb.func_audit = audit_callback;
selinux_set_callback(SELINUX_CB_AUDIT, cb);

selinux_initialize();

restorecon("/dev");
restorecon("/dev/socket");
restorecon("/dev/__properties__");
restorecon_recursive("/sys");

/*load 默认的properties*/
if (!is_charger)
    property_load_boot_defaults();

/*init 的主要工作之一:解析 init.rc */
INFO("reading config file\n");
init_parse_config_file("/init.rc");

/*action_for_each_trigger 和 queue_builtin_action 将 action/command 都是加入到 command 队列里面，等待合适的时机执行*/
action_for_each_trigger("early-init", action_add_queue_tail);

queue_builtin_action(wait_for_coldboot_done_action, "wait_for_coldboot_done");
queue_builtin_action(mix_hwrng_into_linux_rng_action, "mix_hwrng_into_linux_rng");
queue_builtin_action(keychord_init_action, "keychord_init");
queue_builtin_action(console_init_action, "console_init");


/* execute all the boot actions to get us started */
action_for_each_trigger("init", action_add_queue_tail);

if (!is_charger) {
    action_for_each_trigger("early-fs", action_add_queue_tail);
    action_for_each_trigger("fs", action_add_queue_tail);
    action_for_each_trigger("post-fs", action_add_queue_tail);
    action_for_each_trigger("post-fs-data", action_add_queue_tail);
} 

queue_builtin_action(mix_hwrng_into_linux_rng_action, "mix_hwrng_into_linux_rng");

queue_builtin_action(property_service_init_action, "property_service_init");
queue_builtin_action(signal_init_action, "signal_init");
queue_builtin_action(check_startup_action, "check_startup");

if (is_charger) {
    action_for_each_trigger("charger", action_add_queue_tail);
} else {
    action_for_each_trigger("early-boot", action_add_queue_tail);
    action_for_each_trigger("boot", action_add_queue_tail);
}

/* run all property triggers based on current state of the properties */
queue_builtin_action(queue_property_triggers_action, "queue_property_triggers");
</code></pre>

<h1>if BOOTCHART</h1>

<pre><code>queue_builtin_action(bootchart_init_action, "bootchart_init");
</code></pre>

<h1>endif</h1>

<pre><code>/*解析完 init.rc 之后到此的这一段，好像都是在想队列里面添加 action/command*/

/*什么时候来执行呢？下面！*/

/*init 最后进入了一个无限循环，不会主动退出！*/
for(;;) {
    int nr, i, timeout = -1;

    /*执行command 队列里面的一条命令!*/
    execute_one_command();
    restart_processes();

    /*添加property fd (socket） 到 ufds */
    if (!property_set_fd_init &amp;&amp; get_property_set_fd() &gt; 0) {
        ufds[fd_count].fd = get_property_set_fd();
        ufds[fd_count].events = POLLIN;
        ufds[fd_count].revents = 0;
        fd_count++;
        property_set_fd_init = 1;
    }

    /*添加 signal fd 到 ufds*/
    if (!signal_fd_init &amp;&amp; get_signal_fd() &gt; 0) {
        ufds[fd_count].fd = get_signal_fd();
        ufds[fd_count].events = POLLIN;
        ufds[fd_count].revents = 0;
        fd_count++;
        signal_fd_init = 1;
    }

    /*添加 keychord ?fd 到 ufds*/
    if (!keychord_fd_init &amp;&amp; get_keychord_fd() &gt; 0) {
        ufds[fd_count].fd = get_keychord_fd();
        ufds[fd_count].events = POLLIN;
        ufds[fd_count].revents = 0;
        fd_count++;
        keychord_fd_init = 1;
    }

    /*计算进程restart 时间*/
    if (process_needs_restart) {
        timeout = (process_needs_restart - gettime()) * 1000;
        if (timeout &lt; 0)
            timeout = 0;
    }

    if (!action_queue_empty() || cur_action)
        timeout = 0;
</code></pre>

<h1>if BOOTCHART</h1>

<pre><code>    if (bootchart_count &gt; 0) {
        if (timeout &lt; 0 || timeout &gt; BOOTCHART_POLLING_MS)
            timeout = BOOTCHART_POLLING_MS;
        if (bootchart_step() &lt; 0 || --bootchart_count == 0) {
            bootchart_finish();
            bootchart_count = 0;
        }
    }
</code></pre>

<h1>endif</h1>

<pre><code>    /*poll出 ufds 的事件，等待 timeout 时间*/
    nr = poll(ufds, fd_count, timeout);
    if (nr &lt;= 0)
        continue;
   /*处理 ufds 事件!(property set , signal,keychord?)*/
    for (i = 0; i &lt; fd_count; i++) {
        if (ufds[i].revents == POLLIN) {
            if (ufds[i].fd == get_property_set_fd())
                handle_property_set_fd();
            else if (ufds[i].fd == get_keychord_fd())
                handle_keychord();
            else if (ufds[i].fd == get_signal_fd())
                handle_signal();
        }
    }

}
</code></pre>

<p>}</p>

<p>```</p>

<p>代码看下来，可以看出来，init 的主要工作就是:</p>

<ol>
<li>解析 init.rc 文件并执行相应的 action/commands.</li>
<li>作为一个 Daemon 进程处理 property_set,keychord(key combo） 和 signal 事件。</li>
</ol>


<p>init.rc 的解析过程略过，详情请见 system/core/init/init_parser.c</p>

<p>下面来看看 init.rc 里面究竟干了些什么？</p>

<p>```sh system/core/rootdir/init.rc</p>

<h1>导入其他 rc 文件</h1>

<p>import /init.environ.rc
import /init.usb.rc
import /init.${ro.hardware}.rc  #这里保留了导入特定平台相关 rc 的接口,这里可能导入很多东西！
import /init.trace.rc</p>

<h1>early-init 要处理的事情</h1>

<p>on early-init</p>

<pre><code># Set init and its forked children's oom_adj.
write /proc/1/oom_adj -16 

# Set the security context for the init process.
# This should occur before anything else (e.g. ueventd) is started.
setcon u:r:init:s0

start ueventd
</code></pre>

<h1>create mountpoints</h1>

<pre><code>mkdir /mnt 0775 root system
</code></pre>

<h1>init 要处理的事情</h1>

<p>on init</p>

<p>sysclktz 0</p>

<p>loglevel 3</p>

<h1>Backward compatibility</h1>

<pre><code>symlink /system/etc /etc
symlink /sys/kernel/debug /d
</code></pre>

<h1>Right now vendor lives on the same filesystem as system,</h1>

<h1>but someday that may change.</h1>

<pre><code>symlink /system/vendor /vendor
</code></pre>

<h1>&hellip;省略部分代码</h1>

<p>on post-fs</p>

<pre><code># once everything is setup, no need to modify /
mount rootfs rootfs / ro remount
# mount shared so changes propagate into child namespaces
mount rootfs rootfs / shared rec
mount tmpfs tmpfs /mnt/secure private rec
</code></pre>

<h1>&hellip;省略部分代码</h1>

<p>on post-fs-data</p>

<pre><code># We chown/chmod /data again so because mount is run as root + defaults
chown system system /data
chmod 0771 /data
# We restorecon /data in case the userdata partition has been reset.
restorecon /data
</code></pre>

<h1>&hellip;省略部分代码</h1>

<p>on boot</p>

<h1>basic network init</h1>

<pre><code>ifup lo
hostname localhost
domainname localdomain
</code></pre>

<h1>&hellip;省略部分代码</h1>

<h1>这两句重要！！</h1>

<pre><code>class_start core
class_start main
</code></pre>

<p>on nonencrypted</p>

<pre><code>class_start late_start
</code></pre>

<p>on charger</p>

<pre><code>class_start charger
</code></pre>

<p>on property:vold.decrypt=trigger_reset_main</p>

<pre><code>class_reset main
</code></pre>

<h1>&hellip;省略部分代码</h1>

<p>service console /system/bin/sh</p>

<pre><code>class core
console
disabled
user shell
group log
</code></pre>

<h1>&hellip;省略部分代码</h1>

<p>service servicemanager /system/bin/servicemanager</p>

<pre><code>class core
user system
group system
critical
onrestart restart healthd
onrestart restart zygote
onrestart restart media
onrestart restart surfaceflinger
onrestart restart drm
</code></pre>

<h1>&hellip;省略部分代码</h1>

<p>service zygote /system/bin/app_process -Xzygote /system/bin &mdash;zygote &mdash;start-system-server</p>

<pre><code>class main
socket zygote stream 660 root system
onrestart write /sys/android_power/request_state wake
onrestart write /sys/power/state on
onrestart restart media
onrestart restart netd
</code></pre>

<p>```</p>

<p>虽然 ini.rc 里面这么多内容，但是你仔细观察就会发现，这里面只有两种模式：</p>

<ul>
<li>第一种 trigger 触发
<code>
on trigger
 ...
</code></li>
<li>第二种 service
<code>
service ...
 ...
</code></li>
</ul>


<p><code>on xxxx</code> 这种是基于某个事件触发， init.rc 里面列举的有</p>

<ul>
<li>on early-init</li>
<li>on init</li>
<li>on post-fs</li>
<li>on boot</li>
<li>on nonencrypted</li>
<li>on charger</li>
<li>on property:key=value</li>
</ul>


<p>你一定会奇怪，这些 trigger 是如何定义的，在什么时间点触发？ 其实这些 trigger 没有定义，触发的顺序由 init.c 里面添加它们到 action queue 的顺序决定。</p>

<p><code>c  system/core/init/init.c
action_for_each_trigger("early-init", action_add_queue_tail);
...
action_for_each_trigger("init", action_add_queue_tail);
action_for_each_trigger("early-fs", action_add_queue_tail);
...
</code></p>

<p>在 init.c 中以合适的顺序添加到 action queue 里面之后，在 init.c 最后依次从 action queue 中取出这些 action,顺序执行。</p>

<p>```c system/core/init/init.c</p>

<pre><code>for(;;) {
    int nr, i, timeout = -1;

    execute_one_command();  //这里取出 action 来执行。
    ...
}
</code></pre>

<p>```</p>

<p><code>on property</code> 例外，这个是在 set property 之后，查询有没有相关的 action，如果有的话添加到 action queue , 等待取出来执行。</p>

<p>那么 service 是如何启动的呢？service 并没有像 trigger 一样的方式进入 action queue.仔细观察一下 service 里面的 option 就会发现，每个 service 都有一个 class.</p>

<p>```
service ueventd /sbin/ueventd</p>

<pre><code>class core
</code></pre>

<p>service servicemanager /system/bin/servicemanager</p>

<pre><code>class core
</code></pre>

<p>service healthd-charger /sbin/healthd -n</p>

<pre><code>class charger
</code></pre>

<p>service netd /system/bin/netd</p>

<pre><code>class main
</code></pre>

<p>service zygote /system/bin/app_process -Xzygote /system/bin &mdash;zygote &mdash;start-system-server</p>

<pre><code>class main
</code></pre>

<p>&hellip;
```</p>

<p>这个 class 指的就是 service 的类别， service 不是像 trigger 一样，通过名字来查找，而是通过类别来一起启动的。</p>

<p>在 <code>on boot</code>，可以看到:</p>

<p>```
on boot
&hellip;</p>

<pre><code>class_start core
class_start main
</code></pre>

<p>```</p>

<p><code>core</code> 和 <code>main</code> 类别的 service 在 <code>on boot</code> 的时候被一起启动了.</p>

<p>通过上面的分析，可以看得出来，虽然 init.rc 里面的内容很多，但还是很容易理解的：</p>

<ul>
<li>on xxx 是在 init.c 里面通过 xxx 关键字进入 action 队列并顺序执行的。</li>
<li>service xxx 是以 <code>class xxx</code> 分类的，一类在一起进入队列并执行的， core 和 main 类别的 service 是 on boot 的时候一起执行的。</li>
</ul>


<p>OK, 看得出来，其实那些 service 并没有什么特别的，都是 init 启动的而已。</p>

<p>那么，Android 是如何从 Native 切换到 Java 世界的呢？这依赖于 init.rc 里面启动的一个重要 service  &mdash; zygote</p>

<p>zygote 是在 init.rc 中被定义为一个 service ：</p>

<p>```bash
service zygote /system/bin/app_process -Xzygote /system/bin &mdash;zygote &mdash;start-system-server</p>

<pre><code>class main
socket zygote stream 660 root system
onrestart write /sys/android_power/request_state wake
onrestart write /sys/power/state on
onrestart restart media
onrestart restart netd
</code></pre>

<p>```</p>

<p>name = <code>zygote</code>
path = <code>/system/bin/app_process</code>
arguments = <code>-Xzygote /system/bin --zygote --start-system-server</code></p>

<p>zygote 这个 service 在启动的时候实际上是执行了 /system/bin/app_process 这个二进制文件 , 这个文件的源码在:</p>

<p><code>frameworks/base/cmds/app_process/app_main.cpp</code></p>

<p>```c frameworks/base/cmds/app_process/app_main.cpp
int main(int argc, char* const argv[])
{
&hellip;
//-Xzygote 传给 Vm</p>

<pre><code>int i = runtime.addVmArguments(argc, argv);
</code></pre>

<p>&hellip;
//其他参数解析</p>

<pre><code>while (i &lt; argc) {
    const char* arg = argv[i++];
    if (!parentDir) {
        parentDir = arg;
    } else if (strcmp(arg, "--zygote") == 0) {
        zygote = true;
        niceName = "zygote";
    } else if (strcmp(arg, "--start-system-server") == 0) {
        startSystemServer = true;
    } else if (strcmp(arg, "--application") == 0) {
        application = true;
    } else if (strncmp(arg, "--nice-name=", 12) == 0) {
        niceName = arg + 12;
    } else {
        className = arg; 
        break;
    }
}
</code></pre>

<p>&hellip;
// call runtime.start 并 传了两个参数</p>

<pre><code>if (zygote) {
    runtime.start("com.android.internal.os.ZygoteInit",
            startSystemServer ? "start-system-server" : "");
}
...
</code></pre>

<p>}
```</p>

<p>在最后调用了 <code>runtime</code> 的 start 方法并传入了 <code>com.android.internal.os.ZygoteInit</code> 和 <code>start-system-server</code> 两个参数。</p>

<p><code>runtime</code> 是 <code>AppRuntime</code> 的实例， <code>start</code> 是继承自基类 <code>AndroidRuntime</code> 的方法。</p>

<p>```cpp frameworks/core/jni/AndroidRuntime.cpp
/<em>
 * Start the Android runtime.  This involves starting the virtual machine
 * and calling the &ldquo;static void main(String[] args)&rdquo; method in the class
 * named by &ldquo;className&rdquo;.
 *
 * Passes the main function two arguments, the class name and the specified
 * options string.
 </em>/
void AndroidRuntime::start(const char<em> className, const char</em> options)
{
&hellip;</p>

<pre><code> if (startVm(&amp;mJavaVM, &amp;env) != 0) {
    return;
 }
</code></pre>

<p>&hellip;</p>

<pre><code>onVmCreated(env);
</code></pre>

<p>&hellip;</p>

<pre><code>strArray = env-&gt;NewObjectArray(2, stringClass, NULL);
assert(strArray != NULL);
classNameStr = env-&gt;NewStringUTF(className);
assert(classNameStr != NULL);
env-&gt;SetObjectArrayElement(strArray, 0, classNameStr);
optionsStr = env-&gt;NewStringUTF(options);
env-&gt;SetObjectArrayElement(strArray, 1, optionsStr);
</code></pre>

<p>&hellip;</p>

<pre><code>/*
 * Start VM.  This thread becomes the main thread of the VM, and will
 * not return until the VM exits.
 */
char* slashClassName = toSlashClassName(className);
jclass startClass = env-&gt;FindClass(slashClassName);
if (startClass == NULL) {
    ALOGE("JavaVM unable to locate class '%s'\n", slashClassName);
    /* keep going */
} else {
    jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, "main",
        "([Ljava/lang/String;)V");
    if (startMeth == NULL) {
        ALOGE("JavaVM unable to find main() in '%s'\n", className);
        /* keep going */
    } else {
        env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);
 }
</code></pre>

<p>}
```</p>

<p>调用 <code>start</code> 的时候传递了两个参数 <code>com.android.internal.os.ZygoteInit</code> , <code>start-system-server</code>,对应 <code>start</code> 的两个形参 <code>className</code> 和 <code>options</code>。在 <code>start</code> 里面，可以看到，先是 启动了 VM , 然后将两个参数放到 VM 的 env 里面，在然后，找到 <code>com.android.internal.os.ZygoteInit</code> 并调用其  <code>main</code> 方法 !</p>

<p>哈哈！ 终于开启了 java 世界！ 来看看 <code>ZygoteInit</code> 干了些什么?</p>

<p>```java frameworks/base/core/java/com/android/internal/os/ZygoteInit.java
public static void main(String argv[]) {
&hellip;</p>

<pre><code>        registerZygoteSocket();
</code></pre>

<p>&hellip;</p>

<pre><code>        if (argv[1].equals("start-system-server")) {
            startSystemServer();
        } else if (!argv[1].equals("")) {
            throw new RuntimeException(argv[0] + USAGE_STRING);
        }
</code></pre>

<p>&hellip;</p>

<pre><code>        runSelectLoop();
</code></pre>

<p>&hellip;
}
```</p>

<p><code>ZygoteInit</code> 的 <code>main</code> 里面做了三件事 :</p>

<ol>
<li>注册 zygote socket</li>
<li>启动 system server</li>
<li>无限循环监听 zygote socket 消息。</li>
</ol>


<p>在 init 启动 zygote 的时候创建了一个 socket &ndash; <code>/dev/socket/zygote</code></p>

<p>```bash
service zygote /system/bin/app_process -Xzygote /system/bin &mdash;zygote &mdash;start-system-server</p>

<pre><code>class main
socket zygote stream 660 root system
</code></pre>

<p>&hellip;
```</p>

<p><code>registerZygoteSocket</code> 就是用这个 socket 的 fd 创建了一个 Server socket , 用来接收 client 发来的消息。</p>

<p>然后调用，<code>startSystemServer()</code> 来启动 system server 进程。
```java ZygoteInit.java</p>

<pre><code>/**
 * Prepare the arguments and fork for the system server process.
 */
private static boolean startSystemServer()
        throws MethodAndArgsCaller, RuntimeException {
</code></pre>

<p>&hellip;</p>

<pre><code>    /* Hardcoded command line to start the system server */
    String args[] = { 
        "--setuid=1000",
        "--setgid=1000",
        "--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1032,3001,3002,3003,3006,3007",
        "--capabilities=" + capabilities + "," + capabilities,
        "--runtime-init",
        "--nice-name=system_server",
        "com.android.server.SystemServer",
    };
</code></pre>

<p>&hellip;</p>

<pre><code>        /* Request to fork the system server process */
        pid = Zygote.forkSystemServer(
                parsedArgs.uid, parsedArgs.gid,
                parsedArgs.gids,
                parsedArgs.debugFlags,
                null,
                parsedArgs.permittedCapabilities,
                parsedArgs.effectiveCapabilities);
</code></pre>

<p>&hellip;</p>

<pre><code>    /* For child process */
    if (pid == 0) {
        handleSystemServerProcess(parsedArgs);
    }

    return true;
</code></pre>

<p>```</p>

<p>这一步，调用 <code>Zygote.forkSystemServer</code> , <code>forkSystemServer</code> 又调用了 <code>nativenativeForkSystemServer</code></p>

<p>```java  libcore/dalvik/src/main/java/dalvik/system/Zygote.java</p>

<pre><code>public static int forkSystemServer(int uid, int gid, int[] gids, int debugFlags,
        int[][] rlimits, long permittedCapabilities, long effectiveCapabilities) {
    preFork();
    int pid = nativeForkSystemServer(
            uid, gid, gids, debugFlags, rlimits, permittedCapabilities, effectiveCapabilities);
    postFork();
    return pid;
}
</code></pre>

<p>```</p>

<p><code>nativenativeForkSystemServer</code> 在 dalvik 里面</p>

<p>```cpp dalvik/vm/native/dalvik_system_Zygote.cpp
static void Dalvik_dalvik_system_Zygote_forkSystemServer(</p>

<pre><code>    const u4* args, JValue* pResult)
</code></pre>

<p>{</p>

<pre><code>pid_t pid;
pid = forkAndSpecializeCommon(args, true);

/* The zygote process checks whether the child process has died or not. */
if (pid &gt; 0) {
    int status;

    ALOGI("System server process %d has been created", pid);
    gDvm.systemServerPid = pid;
    /*如果 system server 没启动成功，zygote 会自杀!*/
    if (waitpid(pid, &amp;status, WNOHANG) == pid) {
        ALOGE("System server process %d has died. Restarting Zygote!", pid);
        kill(getpid(), SIGKILL);
    }   
}   
RETURN_INT(pid);
</code></pre>

<p>}
```</p>

<p>来看看 <code>forkAndSpecializeCommon</code>:</p>

<p>```
static pid_t forkAndSpecializeCommon(const u4* args, bool isSystemServer)
{
&hellip;</p>

<pre><code>setSignalHandler();
</code></pre>

<p>&hellip;</p>

<pre><code>pid = fork();
</code></pre>

<p>&hellip;</p>

<pre><code>if (pid == 0) {
    unsetSignalHandler();
}
</code></pre>

<p>&hellip;
}
<code>``
这里 fork 之前，注册了 signal 处理函数</code>setSignalHandler`, 子进程里面又取消了signal 处理函数，说明这个是为父进程 zygote 注册的，来看看里面干了些啥：</p>

<p>```
static void sigchldHandler(int s)
{
&hellip;</p>

<pre><code>    /*
     * If the just-crashed process is the system_server, bring down zygote
     * so that it is restarted by init and system server will be restarted
     * from there.
     */
    if (pid == gDvm.systemServerPid) {
        ALOG(LOG_INFO, ZYGOTE_LOG_TAG,
            "Exit zygote because system server (%d) has terminated",
            (int) pid);
        kill(getpid(), SIGKILL);
    }
</code></pre>

<p>&hellip;
}
```</p>

<p>这里如果 system server 挂了， zygote 又要自杀!!</p>

<p>OK , 假设正常执行，继续回到 <code>startSystemServer</code>, 下一步， system server 和 zygote 分道扬镳了终于, system server 调用 <code>handleSystemServerProcess</code>, zygote 则调用 <code>runSelectLoop()</code>, 先看 zygote <code>runSelectLoop</code>:</p>

<p>```</p>

<pre><code>/** 
 * Runs the zygote process's select loop. Accepts new connections as
 * they happen, and reads commands from connections one spawn-request's
 * worth at a time.
 *
 * @throws MethodAndArgsCaller in a child process when a main() should
 * be executed.
 */
private static void runSelectLoop() throws MethodAndArgsCaller {
    ....
    while (true) {
        ...
        } else if (index == 0) {
            ZygoteConnection newPeer = acceptCommandPeer();
            peers.add(newPeer);
            fds.add(newPeer.getFileDesciptor());
        } else {
            boolean done;
            done = peers.get(index).runOnce();
        }
    }
}
</code></pre>

<p>```</p>

<p><code>acceptCommandPeer()</code> 实际是在阻塞式的等待 client 来发起连接。</p>

<p>```</p>

<pre><code>/**
 * Waits for and accepts a single command connection. Throws
 * RuntimeException on failure.
 */
private static ZygoteConnection acceptCommandPeer() {
    try {
        return new ZygoteConnection(sServerSocket.accept());
    } catch (IOException ex) {
        throw new RuntimeException(
                "IOException during accept()", ex);
    }
}
</code></pre>

<p>```</p>

<p><code>runOnce()</code> 则是 client 建立连接之后，读取 client 发过来的数据，并 fork 出新的进程。</p>

<p>```</p>

<pre><code>boolean runOnce() throws ZygoteInit.MethodAndArgsCaller {
        ...
        args = readArgumentList();
        ...
        pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,
        parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,
        parsedArgs.niceName);
        ...
}
</code></pre>

<p>```</p>

<p>回过头来看 system server <code>handleSystemServerProcess</code>:</p>

<p>```java ZygoteInit.java
 /<em>*
 * Finish remaining work for the newly forked system server process.
 </em>/
 private static void handleSystemServerProcess( ZygoteConnection.Arguments parsedArgs) throws ZygoteInit.MethodAndArgsCaller {</p>

<pre><code>...
RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs);
...
</code></pre>

<p> }
```</p>

<p>调用了 <code>RuntimeInit.zygoteInit</code>:</p>

<p>```java RuntimeInit.java</p>

<pre><code>public static final void zygoteInit(int targetSdkVersion, String[] argv)
        throws ZygoteInit.MethodAndArgsCaller {
    if (DEBUG) Slog.d(TAG, "RuntimeInit: Starting application from zygote");

    //重定向 log
    redirectLogStreams();

    //设置 timezone ,useragent 等等
    commonInit();
    //app_main.cpp 的 onZygoteInit, 初始化 Binder thread pool.
    nativeZygoteInit();

    //
    applicationInit(targetSdkVersion, argv);
} 
</code></pre>

<p>```</p>

<p>继续 <code>applicationInit</code>,传入的 <code>startClass</code> 参数正是 &ldquo;com.android.server.SystemServer&rdquo; , 所以这里是掉到了 <code>SystemServer</code> 的 main 方法。</p>

<p>```java RuntimeInit.java</p>

<pre><code>private static void applicationInit(int targetSdkVersion, String[] argv)
        throws ZygoteInit.MethodAndArgsCaller {
    ...
    // Remaining arguments are passed to the start class's static main
    invokeStaticMain(args.startClass, args.startArgs);
}
</code></pre>

<p>```</p>

<p>终于到了 SystemServer 里面来了 :
```java SystemServer.java</p>

<pre><code>public static void main(String[] args) {
    ...
    System.loadLibrary("android_servers");
    // Initialize native services.
    nativeInit();
    // This used to be its own separate thread, but now it is
    // just the loop we run on the main thread.
    ServerThread thr = new ServerThread();
    thr.initAndLoop();
}
</code></pre>

<p>```</p>

<p>主要干了两件事：</p>

<ol>
<li>nativeInit</li>
<li>ServerThread 启动</li>
</ol>


<p>nativeInit 好像没干啥嘛</p>

<p>```cpp services/jni/com_android_server_SystemServer.cpp
static void android_server_SystemServer_nativeInit(JNIEnv* env, jobject clazz) {</p>

<pre><code>char propBuf[PROPERTY_VALUE_MAX];
property_get("system_init.startsensorservice", propBuf, "1");
if (strcmp(propBuf, "1") == 0) {
    // Start the sensor service
    SensorService::instantiate();
}   
</code></pre>

<p>}
```</p>

<p>ServerThread 里面内容可就多喽 ！</p>

<p>```java SystemServer.java</p>

<pre><code>public void initAndLoop() {
    ...
    Looper.prepareMainLooper();

    //为 window manager 创建一个 handler.
    HandlerThread wmHandlerThread = new HandlerThread("WindowManager");
    wmHandlerThread.start();
    Handler wmHandler = new Handler(wmHandlerThread.getLooper());
    wmHandler.post(new Runnable() {
        @Override
        public void run() {
            android.os.Process.setThreadPriority(
                    android.os.Process.THREAD_PRIORITY_DISPLAY);
            android.os.Process.setCanSelfBackground(false);
        }
    });

    // 启动 installd , Power Manager Activity Manager service.
    boolean onlyCore = false;
    boolean firstBoot = false;
    try {
        installer = new Installer();
        installer.ping();

        power = new PowerManagerService();
        ServiceManager.addService(Context.POWER_SERVICE, power);

        context = ActivityManagerService.main(factoryTest);
    }


    boolean disableStorage = SystemProperties.getBoolean("config.disable_storage", false);
    boolean disableMedia = SystemProperties.getBoolean("config.disable_media", false);
    boolean disableBluetooth = SystemProperties.getBoolean("config.disable_bluetooth", false);
    boolean disableTelephony = SystemProperties.getBoolean("config.disable_telephony", false);
    boolean disableLocation = SystemProperties.getBoolean("config.disable_location", false);
    boolean disableSystemUI = SystemProperties.getBoolean("config.disable_systemui", false);
    boolean disableNonCoreServices = SystemProperties.getBoolean("config.disable_noncore", false);
    boolean disableNetwork = SystemProperties.getBoolean("config.disable_network", false);


    //各种 service add 

    try {
        display = new DisplayManagerService(context, wmHandler);
        ServiceManager.addService(Context.DISPLAY_SERVICE, display, true);

        telephonyRegistry = new TelephonyRegistry(context);
        ServiceManager.addService("telephony.registry", telephonyRegistry);

        if (android.telephony.MSimTelephonyManager.getDefault().isMultiSimEnabled()) {
            msimTelephonyRegistry = new MSimTelephonyRegistry(context);
            ServiceManager.addService("telephony.msim.registry", msimTelephonyRegistry);
        }

        ServiceManager.addService("scheduling_policy", new SchedulingPolicyService());

        String cryptState = SystemProperties.get("vold.decrypt");
        if (ENCRYPTING_STATE.equals(cryptState)) {
            onlyCore = true;
        } else if (ENCRYPTED_STATE.equals(cryptState)) {
            onlyCore = true;
        }

        pm = PackageManagerService.main(context, installer,
                factoryTest != SystemServer.FACTORY_TEST_OFF,
                onlyCore);

        ActivityManagerService.setSystemProcess();

        ServiceManager.addService("entropy", new EntropyMixer(context));

        ServiceManager.addService(Context.USER_SERVICE,
                UserManagerService.getInstance());

        mContentResolver = context.getContentResolver();

            accountManager = new AccountManagerService(context);
            ServiceManager.addService(Context.ACCOUNT_SERVICE, accountManager);

        contentService = ContentService.main(context,
                factoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL);

        ActivityManagerService.installSystemProviders();

        lights = new LightsService(context);

        battery = new BatteryService(context, lights);
        ServiceManager.addService("battery", battery);

        vibrator = new VibratorService(context);
        ServiceManager.addService("vibrator", vibrator);

        consumerIr = new ConsumerIrService(context); 
        ServiceManager.addService(Context.CONSUMER_IR_SERVICE, consumerIr);

        power.init(context, lights, ActivityManagerService.self(), battery,
                BatteryStatsService.getService(),
                ActivityManagerService.self().getAppOpsService(), display);

        alarm = new AlarmManagerService(context);
        ServiceManager.addService(Context.ALARM_SERVICE, alarm);

        Watchdog.getInstance().init(context, battery, power, alarm,
                ActivityManagerService.self());
        Watchdog.getInstance().addThread(wmHandler, "WindowManager thread");

        inputManager = new InputManagerService(context, wmHandler);

        wm = WindowManagerService.main(context, power, display, inputManager,
                wmHandler, factoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL,
                !firstBoot, onlyCore);
        ServiceManager.addService(Context.WINDOW_SERVICE, wm);
        ServiceManager.addService(Context.INPUT_SERVICE, inputManager);

        inputManager.setWindowManagerCallbacks(wm.getInputMonitor());
        inputManager.start();

        display.setWindowManager(wm);
        display.setInputManager(inputManager);


                imm = new InputMethodManagerService(context, wm);
                ServiceManager.addService(Context.INPUT_METHOD_SERVICE, imm);

                ServiceManager.addService(Context.ACCESSIBILITY_SERVICE,
                        new AccessibilityManagerService(context));

        wm.displayReady();

        pm.performBootDexOpt();

                mountService = new MountService(context);
                ServiceManager.addService("mount", mountService);

        if (!disableNonCoreServices) {
                lockSettings = new LockSettingsService(context);
                ServiceManager.addService("lock_settings", lockSettings);

                devicePolicy = new DevicePolicyManagerService(context);
                ServiceManager.addService(Context.DEVICE_POLICY_SERVICE, devicePolicy);
        }

        if (!disableSystemUI) {
                statusBar = new StatusBarManagerService(context, wm);
                ServiceManager.addService(Context.STATUS_BAR_SERVICE, statusBar);
        }


        if (!disableNonCoreServices) {
                ServiceManager.addService(Context.CLIPBOARD_SERVICE,
                        new ClipboardService(context));
        }

        if (!disableNetwork) {
                networkManagement = NetworkManagementService.create(context);
                ServiceManager.addService(Context.NETWORKMANAGEMENT_SERVICE, networkManagement);
        }

        if (!disableNonCoreServices) {
                tsms = new TextServicesManagerService(context);
                ServiceManager.addService(Context.TEXT_SERVICES_MANAGER_SERVICE, tsms);
        }

        if (!disableNetwork) {
                networkStats = new NetworkStatsService(context, networkManagement, alarm);
                ServiceManager.addService(Context.NETWORK_STATS_SERVICE, networkStats);

                networkPolicy = new NetworkPolicyManagerService(
                        context, ActivityManagerService.self(), power,
                        networkStats, networkManagement);
                ServiceManager.addService(Context.NETWORK_POLICY_SERVICE, networkPolicy);

                wifiP2p = new WifiP2pService(context);
                ServiceManager.addService(Context.WIFI_P2P_SERVICE, wifiP2p);

                wifi = new WifiService(context);
                ServiceManager.addService(Context.WIFI_SERVICE, wifi);

                serviceDiscovery = NsdService.create(context);
                ServiceManager.addService(
                        Context.NSD_SERVICE, serviceDiscovery);
        }

        if (!disableNonCoreServices) {
                ServiceManager.addService(Context.UPDATE_LOCK_SERVICE,
                        new UpdateLockService(context));
        }


        /*   
         * MountService has a few dependencies: Notification Manager and
         * AppWidget Provider. Make sure MountService is completely started
         * first before continuing.
         */
        if (mountService != null &amp;&amp; !onlyCore) {
            mountService.waitForAsecScan();
        }

        try {
            if (accountManager != null)
                accountManager.systemReady();
        }

        try {
            if (contentService != null)
                contentService.systemReady();
        }

        try {
            notification = new NotificationManagerService(context, statusBar, lights);
            ServiceManager.addService(Context.NOTIFICATION_SERVICE, notification);
            networkPolicy.bindNotificationManager(notification);
        }

        try {
            ServiceManager.addService(DeviceStorageMonitorService.SERVICE,
                    new DeviceStorageMonitorService(context));
        }

        if (!disableLocation) {
                location = new LocationManagerService(context);
                ServiceManager.addService(Context.LOCATION_SERVICE, location);

                countryDetector = new CountryDetectorService(context);
                ServiceManager.addService(Context.COUNTRY_DETECTOR, countryDetector);
        }

        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "Search Service");
                ServiceManager.addService(Context.SEARCH_SERVICE,
                        new SearchManagerService(context));
            }
        }

        try {
            ServiceManager.addService(Context.DROPBOX_SERVICE,
                    new DropBoxManagerService(context, new File("/data/system/dropbox")));
        }

        if (!disableNonCoreServices &amp;&amp; context.getResources().getBoolean(
                    R.bool.config_enableWallpaperService)) {
            try {
                if (!headless) {
                    wallpaper = new WallpaperManagerService(context);
                    ServiceManager.addService(Context.WALLPAPER_SERVICE, wallpaper);
                }
            }
        }

        if (!disableMedia &amp;&amp; !"0".equals(SystemProperties.get("system_init.startaudioservice"))) {
            try {
                ServiceManager.addService(Context.AUDIO_SERVICE, new AudioService(context));
            }
        }

        if (!disableNonCoreServices) {
            try {
                // Listen for dock station changes
                dock = new DockObserver(context);
            }
        }

        if (!disableMedia) {
            try {
                // Listen for wired headset changes
                inputManager.setWiredAccessoryCallbacks(
                        new WiredAccessoryManager(context, inputManager));
            } catch (Throwable e) {
                reportWtf("starting WiredAccessoryManager", e);
            }
        }


        if (!disableNonCoreServices) {
            try {
                // Manage USB host and device support
                usb = new UsbService(context);
                ServiceManager.addService(Context.USB_SERVICE, usb);
            }

            try {
                // Serial port support
                serial = new SerialService(context);
                ServiceManager.addService(Context.SERIAL_SERVICE, serial);
            }
        }

        try {
            twilight = new TwilightService(context);
        }

        try {
            // Listen for UI mode changes
            uiMode = new UiModeManagerService(context, twilight);
        }

        if (!disableNonCoreServices) {
            try {
                ServiceManager.addService(Context.BACKUP_SERVICE,
                        new BackupManagerService(context));
            }

            try {
                appWidget = new AppWidgetService(context);
                ServiceManager.addService(Context.APPWIDGET_SERVICE, appWidget);
            }

            try {
                recognition = new RecognitionManagerService(context);
            }
        }

        try {
            ServiceManager.addService("diskstats", new DiskStatsService(context));
        }

        try {
            ServiceManager.addService("samplingprofiler",
                        new SamplingProfilerService(context));
        }

        if (!disableNetwork) {
            try {
                networkTimeUpdater = new NetworkTimeUpdateService(context);
            }
        }

        if (!disableMedia) {
            try {
                commonTimeMgmtService = new CommonTimeManagementService(context);
                ServiceManager.addService("commontime_management", commonTimeMgmtService);
            }
        }

        if (!disableNetwork) {
            try {
                CertBlacklister blacklister = new CertBlacklister(context);
            }
        }

        if (!disableNonCoreServices &amp;&amp;
            context.getResources().getBoolean(R.bool.config_dreamsSupported)) {
            try {
                // Dreams (interactive idle-time views, a/k/a screen savers)
                dreamy = new DreamManagerService(context, wmHandler);
                ServiceManager.addService(DreamService.DREAM_SERVICE, dreamy);
            }
        }

        if (!disableNonCoreServices) {
            try {
                atlas = new AssetAtlasService(context);
                ServiceManager.addService(AssetAtlasService.ASSET_ATLAS_SERVICE, atlas);
            }
        }


        try {
            new IdleMaintenanceService(context, battery);
        }

        try {
            printManager = new PrintManagerService(context);
            ServiceManager.addService(Context.PRINT_SERVICE, printManager);
        }

        if (!disableNonCoreServices) {
            try {
                mediaRouter = new MediaRouterService(context);
                ServiceManager.addService(Context.MEDIA_ROUTER_SERVICE, mediaRouter);
            }
        }
    //safe mode 相关
    final boolean safeMode = wm.detectSafeMode();
    if (safeMode) {
        ActivityManagerService.self().enterSafeMode();
        // Post the safe mode state in the Zygote class
        Zygote.systemInSafeMode = true;
        // Disable the JIT for the system_server process
        VMRuntime.getRuntime().disableJitCompilation();
    } else {
        // Enable the JIT for the system_server process
        VMRuntime.getRuntime().startJitCompilation();
    }


    //service system ready
    vibrator.systemReady();
    lockSettings.systemReady();
    devicePolicy.systemReady();
    notification.systemReady();
    wm.systemReady();
    if (safeMode) {
        ActivityManagerService.self().showSafeModeOverlay();
    }
    power.systemReady(twilight, dreamy);
    pm.systemReady();
    display.systemReady(safeMode, onlyCore);

    //接下来是 ActivityManagerService 的 systemReady
    ActivityManagerService.self().systemReady(new Runnable() {
        public void run() {

                ActivityManagerService.self().startObservingNativeCrashes();
                startSystemUi(contextF);
                if (mountServiceF != null) mountServiceF.systemReady();
                if (batteryF != null) batteryF.systemReady();
                if (networkManagementF != null) networkManagementF.systemReady();
                if (networkStatsF != null) networkStatsF.systemReady();
                if (networkPolicyF != null) networkPolicyF.systemReady();
                if (connectivityF != null) connectivityF.systemReady();
                if (dockF != null) dockF.systemReady();
                if (usbF != null) usbF.systemReady();
                if (twilightF != null) twilightF.systemReady();
                if (uiModeF != null) uiModeF.systemReady();
                if (recognitionF != null) recognitionF.systemReady();
            Watchdog.getInstance().start();

            // It is now okay to let the various system services start their
            // third party code...

                if (appWidgetF != null) appWidgetF.systemRunning(safeMode);
                if (wallpaperF != null) wallpaperF.systemRunning();
                if (immF != null) immF.systemRunning(statusBarF);
                if (locationF != null) locationF.systemRunning();
                if (countryDetectorF != null) countryDetectorF.systemRunning();
                if (networkTimeUpdaterF != null) networkTimeUpdaterF.systemRunning();
                if (commonTimeMgmtServiceF != null) commonTimeMgmtServiceF.systemRunning();
                    textServiceManagerServiceF.systemRunning();
                if (dreamyF != null) dreamyF.systemRunning();
                if (atlasF != null) atlasF.systemRunning();
                if (inputManagerF != null) inputManagerF.systemRunning();
                if (telephonyRegistryF != null) telephonyRegistryF.systemRunning();
                if (msimTelephonyRegistryF != null) msimTelephonyRegistryF.systemRunning();
                if (printManagerF != null) printManagerF.systemRuning();
                if (mediaRouterF != null) mediaRouterF.systemRunning();

    //进入消息循环
    Looper.loop();
}
</code></pre>

<p>```</p>

<p>system server 启动了，来看下 Launcher 是怎么启动的。system server 的最后一段调用了 ActivityManagerService 的 systemReady() 回调。</p>

<p>ActivityManagerService 的 systemReady()：</p>

<p>```java ActivityManagerService.java</p>

<pre><code>public void systemReady(final Runnable goingCallback) {
    ...
        mStackSupervisor.resumeTopActivitiesLocked();
    ...
}
</code></pre>

<p>```</p>

<p>&ndash;>mStackSupervisor.resumeTopActivitiesLocked</p>

<p>```java ActivityStackSupervisor.java</p>

<pre><code>boolean resumeTopActivitiesLocked() {
    return resumeTopActivitiesLocked(null, null, null);
}    

boolean resumeTopActivitiesLocked(ActivityStack targetStack, ActivityRecord target,
        Bundle targetOptions) {
    if (targetStack == null) {
        targetStack = getFocusedStack();
    }    
    boolean result = false;
    for (int stackNdx = mStacks.size() - 1; stackNdx &gt;= 0; --stackNdx) {
        final ActivityStack stack = mStacks.get(stackNdx);
        if (isFrontStack(stack)) {
            if (stack == targetStack) {
                result = stack.resumeTopActivityLocked(target, targetOptions);
            } else {
                stack.resumeTopActivityLocked(null);
            }    
        }    
    }    
    return result;
} 
</code></pre>

<p>```</p>

<p>&ndash;>stack.resumeTopActivityLocked</p>

<p>```java ActivityStack.java</p>

<pre><code>final boolean resumeTopActivityLocked(ActivityRecord prev) {
    return resumeTopActivityLocked(prev, null);
}

final boolean resumeTopActivityLocked(ActivityRecord prev, Bundle options) {
    if (ActivityManagerService.DEBUG_LOCKSCREEN) mService.logLockScreen("");
    ...
    if (next == null) {
        // There are no more activities!  Let's just start up the
        // Launcher...
        ActivityOptions.abort(options);
        if (DEBUG_STATES) Slog.d(TAG, "resumeTopActivityLocked: No more activities go home");
        if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();
        return mStackSupervisor.resumeHomeActivity(prev);
    }   
</code></pre>

<p>```</p>

<p>&ndash;>mStackSupervisor.resumeHomeActivity</p>

<p>```java ActivityStackSupervisor.java</p>

<pre><code>boolean resumeHomeActivity(ActivityRecord prev) {
    ...  
    return mService.startHomeActivityLocked(mCurrentUser);
} 
</code></pre>

<p>```</p>

<p>&ndash;>mService.startHomeActivityLocked(mCurrentUser)</p>

<p>```java ActivityManagerService.java</p>

<pre><code>boolean startHomeActivityLocked(int userId) {
    Intent intent = getHomeIntent();
    ActivityInfo aInfo =
        resolveActivityInfo(intent, STOCK_PM_FLAGS, userId);
    if (aInfo != null) {
        intent.setComponent(new ComponentName(
                aInfo.applicationInfo.packageName, aInfo.name));
        // Don't do this if the home app is currently being
        // instrumented.
        aInfo = new ActivityInfo(aInfo);
        aInfo.applicationInfo = getAppInfoForUser(aInfo.applicationInfo, userId);
        ProcessRecord app = getProcessRecordLocked(aInfo.processName,
                aInfo.applicationInfo.uid, true);
        if (app == null || app.instrumentationClass == null) {
            intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK);
            mStackSupervisor.startHomeActivity(intent, aInfo);
        }
    }
}
</code></pre>

<p>```
&ndash;> mStackSupervisor.startHomeActivity</p>

<p>```java ActivityStackSupervisor.java</p>

<pre><code>void startHomeActivity(Intent intent, ActivityInfo aInfo) {
    moveHomeToTop();
    startActivityLocked(null, intent, null, aInfo, null, null, 0, 0, 0, null, 0,
            null, false, null);
}
</code></pre>

<p>&ndash;>
startActivityLocked
&ndash;>
startActivityUncheckedLocked
&ndash;>
resumeTopActivitiesLocked</p>

<p>```</p>

<p>&ndash;>ActivityStack.resumeTopActivityLocked</p>

<p>&ndash;>
ActivityStackSupervisor.startSpecificActivityLocked</p>

<p>&ndash;>
ActivityManagerService.startProcessLocked</p>

<p>&ndash;></p>

<p>```java ActivityManagerService.java</p>

<pre><code>        // Start the process.  It will either succeed and return a result containing
        // the PID of the new process, or else throw a RuntimeException.
        Process.ProcessStartResult startResult = Process.start("android.app.ActivityThread",
                app.processName, uid, uid, gids, debugFlags, mountExternal,
                app.info.targetSdkVersion, app.info.seinfo, null);
</code></pre>

<p>```
&ndash;>
Process.start 注意这里传入的 processClass 是 &ldquo;android.app.ActivityThread&rdquo;</p>

<p>&ndash;>
startViaZygote</p>

<p>```java Process.java</p>

<pre><code>public static final ProcessStartResult start(final String processClass,
                              final String niceName,
                              int uid, int gid, int[] gids,
                              int debugFlags, int mountExternal,
                              int targetSdkVersion,
                              String seInfo,
                              String[] zygoteArgs) {
    try {
        return startViaZygote(processClass, niceName, uid, gid, gids,
                debugFlags, mountExternal, targetSdkVersion, seInfo, zygoteArgs);
    } catch (ZygoteStartFailedEx ex) {
        Log.e(LOG_TAG,
                "Starting VM process through Zygote failed");
        throw new RuntimeException(
                "Starting VM process through Zygote failed", ex); 
    }    
}
</code></pre>

<p>```</p>

<p>&ndash;></p>

<p>```java Process.java</p>

<pre><code>private static ProcessStartResult startViaZygote(final String processClass,
                              final String niceName,
                              final int uid, final int gid,
                              final int[] gids,
                              int debugFlags, int mountExternal,
                              int targetSdkVersion,
                              String seInfo,
                              String[] extraArgs)
                              throws ZygoteStartFailedEx {
         ...
         return zygoteSendArgsAndGetResult(argsForZygote);
}
</code></pre>

<p>```</p>

<p>```java Process.java</p>

<pre><code>private static ProcessStartResult zygoteSendArgsAndGetResult(ArrayList&lt;String&gt; args)
        throws ZygoteStartFailedEx {
    openZygoteSocketIfNeeded();
    ...
        sZygoteWriter.write(Integer.toString(args.size()));            sZygoteWriter.newLine();
    ...
        sZygoteWriter.write(arg);
}
</code></pre>

<p>```</p>

<p>openZygoteSocketIfNeeded?</p>

<p>```java Process.java</p>

<pre><code>private static final String ZYGOTE_SOCKET = "zygote";
private static void openZygoteSocketIfNeeded()
        throws ZygoteStartFailedEx {
            sZygoteSocket = new LocalSocket();

            sZygoteSocket.connect(new LocalSocketAddress(ZYGOTE_SOCKET,
                    LocalSocketAddress.Namespace.RESERVED));
}
</code></pre>

<p>```</p>

<p>yes &ndash;> connect to &ldquo;zygote&rdquo; and send args, back to zygote:</p>

<p>```java ZygoteInit.java
   private static void runSelectLoop(){</p>

<pre><code>            done = peers.get(index).runOnce();
</code></pre>

<p>   }
```</p>

<p>&ndash;>runOnce?</p>

<p>```java ZygoteConnection.java
boolean runOnce(){
&hellip;</p>

<pre><code>        pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,
                parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,
                parsedArgs.niceName);
</code></pre>

<p>&hellip;
handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);
}
```
&ndash;>
Zygote.forkAndSpecialize</p>

<p>```java Zygote.java</p>

<pre><code>public static int forkAndSpecialize(int uid, int gid, int[] gids, int debugFlags,
        int[][] rlimits, int mountExternal, String seInfo, String niceName) {
    preFork();
    int pid = nativeForkAndSpecialize(
            uid, gid, gids, debugFlags, rlimits, mountExternal, seInfo, niceName);
    postFork();
    return pid;
}
</code></pre>

<p>```</p>

<p>&ndash;> nativeForkAndSpecialize
```cpp dalvik_system_Zygote.cpp
static void Dalvik_dalvik_system_Zygote_forkAndSpecialize(const u4* args,</p>

<pre><code>JValue* pResult)
</code></pre>

<p>{</p>

<pre><code>pid_t pid;

pid = forkAndSpecializeCommon(args, false);

RETURN_INT(pid);
</code></pre>

<p>}</p>

<p>static pid_t forkAndSpecializeCommon(const u4* args, bool isSystemServer)
{
&hellip;
 pid = fork();
&hellip;
return pid;
}
```</p>

<p>fork 创建新进程，返回到 ZygoteConnection 的 runOnce.</p>

<p>```java frameworks/base/core/java/com/android/internal/os/ZygoteConnection.java
 boolean runOnce() throws ZygoteInit.MethodAndArgsCaller {
&hellip;</p>

<pre><code>    try {
        if (pid == 0) {
            // in child
            IoUtils.closeQuietly(serverPipeFd);
            serverPipeFd = null;
            handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);

            // should never get here, the child is expected to either
            // throw ZygoteInit.MethodAndArgsCaller or exec().
            return true;
        } else {
            // in parent...pid of &lt; 0 means failure
            IoUtils.closeQuietly(childPipeFd);
            childPipeFd = null;
            return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);
        }
    } finally {
        IoUtils.closeQuietly(childPipeFd);
        IoUtils.closeQuietly(serverPipeFd);
    }
</code></pre>

<p>&hellip;
}
```</p>

<p>子进程进入 &ndash;> handleChildProc</p>

<p>```java frameworks/base/core/java/com/android/internal/os/ZygoteConnection.java</p>

<pre><code>private void handleChildProc(Arguments parsedArgs,
        FileDescriptor[] descriptors, FileDescriptor pipeFd, PrintStream newStderr)
        throws ZygoteInit.MethodAndArgsCaller {
</code></pre>

<p>&hellip;</p>

<pre><code>                ZygoteInit.invokeStaticMain(cloader, className, mainArgs);
</code></pre>

<p>&hellip;</p>

<pre><code>}
</code></pre>

<p>```</p>

<p>调用 className 的 main 方法, className 是哪个呢？就是上面传入的 &ldquo;android.app.ActivityThread&rdquo;</p>

<p>&ndash;>
```java frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</p>

<pre><code>static void invokeStaticMain(ClassLoader loader,
        String className, String[] argv)
        throws ZygoteInit.MethodAndArgsCaller {
     ...
     cl = loader.loadClass(className);
     m = cl.getMethod("main", new Class[] { String[].class });
     ...
    /*
     * This throw gets caught in ZygoteInit.main(), which responds
     * by invoking the exception's run() method. This arrangement
     * clears up all the stack frames that were required in setting
     * up the process.
     */
    throw new ZygoteInit.MethodAndArgsCaller(m, argv);

}
</code></pre>

<p>```</p>

<p>抛出异常，返回到 ZygoteInit.main() 里面 ;&ndash;)</p>

<p>```java frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</p>

<pre><code>public static void main(String argv[]) {
    try {
        ...
    } catch (MethodAndArgsCaller caller) {
        caller.run();
    }
    ...
}
</code></pre>

<p>```
在这里执行 &ldquo;android.app.ActivityThread&rdquo; 的 main 方法.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[alarm]]></title>
    <link href="http://SteveVallay.github.io/blog/2013/12/27/alarm/"/>
    <updated>2013-12-27T14:40:00+08:00</updated>
    <id>http://SteveVallay.github.io/blog/2013/12/27/alarm</id>
    <content type="html"><![CDATA[<p>关于时间，我们还知之甚少。</p>

<!-- more -->


<p>不知道是谁发现了时间这个 NB 的概念! 有了时间，使得我们可以知道从一个事件到另外一个事件，中间经历了多久。时间参考系的建立，使得我们可以即使在不同的地点也可以取得同步，完成协作。</p>

<p>每个系统都要维持一个时钟系统，一方面维持自身的秩序，另一方面和外界取得一致。</p>

<p>Linux 和 Android 都不例外。在手机上我们需要时间系统提供什么样的服务呢？</p>

<ul>
<li>允许我设置时间/同步时间。</li>
<li>告诉我现在是什么时间。</li>
<li>告诉我系统运行了多长时间。</li>
<li>允许我设置特定时间提醒。</li>
</ul>


<p>先来看看设置特定时间提醒这个功能。</p>

<p>这个特定时间，有两个参考系:</p>

<ul>
<li>RTC</li>
<li>ELAPSED_REALTIME</li>
</ul>


<p><code>RTC</code> 指得就是当前时间,UTC时间，java api <code>System.currentTimeMillis()</code> 返回的时间，通过这个时间我们知道现在是几年几月几日几时几分几秒。</p>

<p><code>ELAPSED_REALTIME</code> 指的是过去的时间，从开机开始过去了多久， java api <code>SystemClock.elapsedRealtime()</code> 返回的时间， 通过这个时间我们知道系统运行了多久。</p>

<p>由于手机系统会有 &ldquo;休眠&rdquo; 状态，特定时间提醒这个服务在 &ldquo;休眠&rdquo; 状态可以有两种选择，唤醒手机提醒，或者不唤醒手机，等待手机被其他原因唤醒后再提醒。针对这个特性，又添加了两种类型:</p>

<ul>
<li>RTC_WAKEUP</li>
<li>ELAPSED_REALTIME_WAKEUP</li>
</ul>


<p><code>RTC_WAKEUP</code> 基于 UTC 时间，唤醒手机进行提醒，<code>RTC</code> 默认不会唤醒手机。</p>

<p><code>ELAPSED_REALTIME_WAKEUP</code> 类似的，基于开机过去时间，唤醒手机进行提醒。<code>ELAPSED_REALTIME</code> 不会。</p>

<p>先看下在 app layer 如何设置特定时间提醒:</p>

<p><code>java packages/apps/DeskClock/src/com/android/deskclock/alarms/AlarmStateManager.java
 AlarmManager am = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
 am.set(AlarmManager.RTC_WAKEUP, timeInMillis, pendingIntent);
</code></p>

<p>获取 AlarmManager ，设置在 RTC 时间  <code>timeInMillis</code> 唤醒并触发 <code>pendingIntent</code> 提醒。</p>

<p>我们知道 AlarmManager 是 AlarmManagerService 的代理，它最后会 IPC到 AlarmManagerService 调用相关的接口。</p>

<p>``` java framework/base/core/java/android/app/AlarmManager.java</p>

<pre><code> public void setExact(int type, long triggerAtMillis, PendingIntent operation) {
     setImpl(type, triggerAtMillis, WINDOW_EXACT, 0, operation, null);
 }

 private void setImpl(int type, long triggerAtMillis, long windowMillis, long intervalMillis,
         PendingIntent operation, WorkSource workSource) {
</code></pre>

<p>&hellip;
  try {</p>

<pre><code>         mService.set(type, triggerAtMillis, windowMillis, intervalMillis, operation,
                 workSource);
     } catch (RemoteException ex) {
     }
</code></pre>

<p>}</p>

<p>```</p>

<p>到 AlarmManagerService :</p>

<p>```
 @Override</p>

<pre><code>public void set(int type, long triggerAtTime, long windowLength, long interval,
        PendingIntent operation, WorkSource workSource) {
    if (workSource != null) {
        mContext.enforceCallingPermission(
                android.Manifest.permission.UPDATE_DEVICE_STATS,
                "AlarmManager.set");
    }    

    set(type, triggerAtTime, windowLength, interval, operation, false, workSource);
}
</code></pre>

<p>&ndash;>
 public void set(int type, long triggerAtTime, long windowLength, long interval,</p>

<pre><code>        PendingIntent operation, boolean isStandalone, WorkSource workSource) {
</code></pre>

<p>&hellip;
 setImplLocked(type, triggerAtTime, triggerElapsed, windowLength, maxElapsed,</p>

<pre><code>                interval, operation, isStandalone, true, workSource);
</code></pre>

<p>}</p>

<p>&ndash;></p>

<p> private void setImplLocked(int type, long when, long whenElapsed, long windowLength,</p>

<pre><code>        long maxWhen, long interval, PendingIntent operation, boolean isStandalone,
        boolean doValidate, WorkSource workSource) {
</code></pre>

<p>&hellip;
rescheduleKernelAlarmsLocked();
}</p>

<p>&ndash;></p>

<p>  private void rescheduleKernelAlarmsLocked() {</p>

<pre><code>    // Schedule the next upcoming wakeup alarm.  If there is a deliverable batch
    // prior to that which contains no wakeups, we schedule that as well.
    if (mAlarmBatches.size() &gt; 0) {
        final Batch firstWakeup = findFirstWakeupBatchLocked();
        final Batch firstBatch = mAlarmBatches.get(0);
        if (firstWakeup != null &amp;&amp; mNextWakeup != firstWakeup.start) {
            mNextWakeup = firstWakeup.start;
            setLocked(ELAPSED_REALTIME_WAKEUP, firstWakeup.start);
        }
        if (firstBatch != firstWakeup &amp;&amp; mNextNonWakeup != firstBatch.start) {
            mNextNonWakeup = firstBatch.start;
            setLocked(ELAPSED_REALTIME, firstBatch.start);
        }
    }
}
</code></pre>

<p>&ndash;></p>

<p> private void setLocked(int type, long when)</p>

<pre><code>{
      if (mDescriptor != -1)
    {
        // The kernel never triggers alarms with negative wakeup times
        // so we ensure they are positive.
        long alarmSeconds, alarmNanoseconds;
        if (when &lt; 0) {
            alarmSeconds = 0;
            alarmNanoseconds = 0;
        } else {
            alarmSeconds = when / 1000;
            alarmNanoseconds = (when % 1000) * 1000 * 1000;
        }

        set(mDescriptor, type, alarmSeconds, alarmNanoseconds);
}
</code></pre>

<p>&ndash;>
private native void set(int fd, int type, long seconds, long nanoseconds);
```</p>

<p>native 方法:</p>

<p>```cpp frameworks/base/services/jni/com_android_server_AlarmManagerService.cpp</p>

<p>static void android_server_AlarmManagerService_set(JNIEnv* env, jobject obj, jint fd, jint type, jlong seconds, jlong nanoseconds)
{</p>

<pre><code>struct timespec ts; 
ts.tv_sec = seconds;
ts.tv_nsec = nanoseconds;

int result = ioctl(fd, ANDROID_ALARM_SET(type), &amp;ts);
if (result &lt; 0)
{   
    ALOGE("Unable to set alarm to %lld.%09lld: %s\n", seconds, nanoseconds, strerror(errno));
}   
</code></pre>

<p>}</p>

<p>```
fd 从哪里来的？AlarmManagerService 初始化来的:</p>

<p>``` java frameworks/services/java/com/android/server/AlarmManagerService.java
 public AlarmManagerService(Context context) {</p>

<pre><code>    mContext = context;
    mDescriptor = init();
    mNextWakeup = mNextNonWakeup = 0;
    ...
}
</code></pre>

<p>```</p>

<p>init 是 native 方法:</p>

<p>```cpp frameworks/base/services/jni/com_android_server_AlarmManagerService.cpp
static jint android_server_AlarmManagerService_init(JNIEnv* env, jobject obj)
{</p>

<pre><code>return open("/dev/alarm", O_RDWR);
</code></pre>

<p>}
```</p>

<p>在设下 alarm 之后， AlarmManagerService 启动了一个 AlarmThread 来等待 alarm 的事件。</p>

<p>```java frameworks/services/java/com/android/server/AlarmManagerService.java</p>

<p> private final AlarmThread mWaitThread = new AlarmThread();</p>

<p> public AlarmManagerService(Context context) {</p>

<pre><code>     ...
     if (mDescriptor != -1) {
        mWaitThread.start();
    } else {
        Slog.w(TAG, "Failed to open alarm driver. Falling back to a handler.");
    }
}
</code></pre>

<p>```</p>

<p>这个 AlarmThread 就会循环等待 alarm 事件！</p>

<p>```java frameworks/services/java/com/android/server/AlarmManagerService.java
  private class AlarmThread extends Thread</p>

<pre><code>{
    public AlarmThread()
    {
        super("AlarmManager");
    }

    public void run()
    {
        ArrayList&lt;Alarm&gt; triggerList = new ArrayList&lt;Alarm&gt;();

        while (true)
        {
            int result = waitForAlarm(mDescriptor);
            ...
        }
    }
}
</code></pre>

<p>```</p>

<p>等到设定的时间到了的时候， AlarmManagerService 就会收到消息，发送当初设定的 PendingIntent.</p>

<p>这样就满足了设定特定时间提醒的功能。</p>

<p>对于像钟表这样的程序，就需要一种机制，几乎是时时的告诉，当前是什么时间，而且要每一秒都要更新。这个需求怎么满足呢？</p>

<p>Android 的设计中有一个 Intent 是标识这种时间改变的，但是不是每秒，是每分钟啊 ！！
```java Intent.java</p>

<pre><code>/**  
 * Broadcast Action: The current time has changed.  Sent every
 * minute.  You can &lt;em&gt;not&lt;/em&gt; receive this through components declared
 * in manifests, only by explicitly registering for it with
 * {@link Context#registerReceiver(BroadcastReceiver, IntentFilter)
 * Context.registerReceiver()}.
 *
 * &lt;p class="note"&gt;This is a protected intent that can only be sent
 * by the system.
 */
@SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
public static final String ACTION_TIME_TICK = "android.intent.action.TIME_TICK";
</code></pre>

<p>```</p>

<p>你只要注册了这个 Intent , 每分钟开始的时候都会受到这个 Intent。AlarmManagerService 是如何提供这个服务的呢？</p>

<p>在 AlarmManagerService 的构造函数中会创建一个 ClockReceiver， 并在 scheduleTimeTickEvent 中调用native <code>set</code> 方法设置一个一分钟后的时间提醒，设置的 PendingIntent 就是 ACTION_TIME_TICK 这个 Intent。</p>

<p>而且，这个 ClockReceiver 还注册了ACTION_TIME_TICK 的监听。一分钟后它自己也会收到 ACTION_TIME_TICK，收到之后，它又调用了一次 scheduleTimeTickEvent，设定了下一分钟的提醒。如是，每分钟都会可以收到这个提醒了！</p>

<p>```java frameworks/services/java/com/android/server/AlarmManagerService.java
  public AlarmManagerService(Context context) {</p>

<pre><code>    ...

    mTimeTickSender = PendingIntent.getBroadcastAsUser(context, 0,
            new Intent(Intent.ACTION_TIME_TICK).addFlags(
                    Intent.FLAG_RECEIVER_REGISTERED_ONLY
                    | Intent.FLAG_RECEIVER_FOREGROUND), 0,
                    UserHandle.ALL);
    // now that we have initied the driver schedule the alarm
    mClockReceiver= new ClockReceiver();
    mClockReceiver.scheduleTimeTickEvent();
    ...

}
</code></pre>

<p>   class ClockReceiver extends BroadcastReceiver {</p>

<pre><code>    public ClockReceiver() {
        IntentFilter filter = new IntentFilter();
        filter.addAction(Intent.ACTION_TIME_TICK);
        filter.addAction(Intent.ACTION_DATE_CHANGED);
        mContext.registerReceiver(this, filter);
    }
   public void onReceive(Context context, Intent intent) {
        if (intent.getAction().equals(Intent.ACTION_TIME_TICK)) {
            scheduleTimeTickEvent();
    }

  public void scheduleTimeTickEvent() {
        final long currentTime = System.currentTimeMillis();
        final long nextTime = 60000 * ((currentTime / 60000) + 1);

        // Schedule this event for the amount of time that it would take to get to
        // the top of the next minute.
        final long tickEventDelay = nextTime - currentTime;

        final WorkSource workSource = null; // Let system take blame for time tick events.
        set(ELAPSED_REALTIME, SystemClock.elapsedRealtime() + tickEventDelay, 0,
                0, mTimeTickSender, true, workSource);
    }
}
</code></pre>

<p>```</p>

<p>可是这样的话，每秒钟的提醒它肯定满足不了，那么时钟是如何实现秒针的现实的呢？</p>

<p>```java packages/apps/DeskClock/src/com/android/deskclock/AnalogClock.java</p>

<pre><code>protected void onAttachedToWindow() {
 ...
 // tick the seconds
 post(mClockTick);
 ...
}

private final Runnable mClockTick = new Runnable () {

    @Override
    public void run() {
        onTimeChanged();
        invalidate();
        AnalogClock.this.postDelayed(mClockTick, 1000);
    }   
}; 
</code></pre>

<p>```</p>

<p>在创建的时候 post 一个 Runnable， 在 Runnable 中的 run 方法中 又设定了在一秒钟之后，再 post 这个 Runnable。这样每秒钟都会执行 Runnable 一次，进行重新绘制。</p>

<p>DeskClock 中的 widget 插件和应用里面第二个 TAB 中的数字时钟都是使用 <code>TextClock</code>， <code>TextClock</code> 也是监听 <code>ACTION_TIME_TICK</code> 来完成每分钟的更新的。参考代码：</p>

<ul>
<li>frameworks/base/core/java/android/widget/TextClock.java</li>
</ul>


<p>Statusbar 上的 Clock 也是监听 <code>ACTION_TIME_TICK</code> 来完成每分钟的更新的。参考代码:</p>

<ul>
<li>frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/policy/Clock.java</li>
</ul>


<p>Keyguard 上的 Clock 显示也是使用的 <code>TextClock</code> 同上 。</p>

<p>对于分钟这个精度的时间显示都可以使用监听 <code>ACTION_TIME_TICK</code> 的方式来完成。但是收到这个 Intent 的时候并没有将当前的时间传递过来，所以还是需要另外的接口来完成获取当前准确时间的需求。</p>

<p>获取当前 UTC 时间是通过 <code>System.currentTimeMillis()</code> 来完成的。</p>

<p>```java libcore/luni/src/main/java/java/lang/System.java</p>

<pre><code>/** 
 * Returns the current time in milliseconds since January 1, 1970 00:00:00.0 UTC.
 *
 * &lt;p&gt;This method always returns UTC times, regardless of the system's time zone.
 * This is often called "Unix time" or "epoch time".
 * Use a {@link java.text.DateFormat} instance to format this time for display to a human.
 *
 * &lt;p&gt;This method shouldn't be used for measuring timeouts or
 * other elapsed time measurements, as changing the system time can affect
 * the results. Use {@link #nanoTime} for that.
 */
public static native long currentTimeMillis();
</code></pre>

<p>```</p>

<p>为什么定义 1970.1.1 开始呢？因为那大概是Unix诞生的时间。</p>

<p>这个 native 方法调用 <code>gettimeofday</code> 来完成的:</p>

<p>```cpp libcore/luni/src/main/native/java_lang_System.cpp
static jlong System_currentTimeMillis(JNIEnv*, jclass) {</p>

<pre><code>timeval now;
gettimeofday(&amp;now, NULL);
jlong when = now.tv_sec * 1000LL + now.tv_usec / 1000;
return when;
</code></pre>

<p>}
```</p>

<p>在 Linux shell 环境下输入 <code>man gettimeofday</code> 获取更多信息：</p>

<p>```
GETTIMEOFDAY(2)                                      Linux Programmer&rsquo;s Manual                                     GETTIMEOFDAY(2)</p>

<p>NAME</p>

<pre><code>   gettimeofday, settimeofday - get / set time
</code></pre>

<p>SYNOPSIS</p>

<pre><code>   #include &lt;sys/time.h&gt;

   int gettimeofday(struct timeval *tv, struct timezone *tz);
   int settimeofday(const struct timeval *tv, const struct timezone *tz);
</code></pre>

<p>   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):</p>

<pre><code>   settimeofday(): _BSD_SOURCE
</code></pre>

<p>DESCRIPTION</p>

<pre><code>   The  functions  gettimeofday()  and  settimeofday()  can  get and set the time as well as a timezone.  The tv argument is a
   struct timeval (as specified in &lt;sys/time.h&gt;):

       struct timeval {
           time_t      tv_sec;     /* seconds */
           suseconds_t tv_usec;    /* microseconds */
       };

   and gives the number of seconds and microseconds since the Epoch (see time(2)).  The tz argument is a struct timezone:

       struct timezone {
           int tz_minuteswest;     /* minutes west of Greenwich */
           int tz_dsttime;         /* type of DST correction */
       };

   If either tv or tz is NULL, the corresponding structure is not set or returned.
</code></pre>

<p>```</p>

<p>timeval 带有两个成员， <code>tv_sec</code> 保存秒数，<code>tv_usec</code> 保存微秒(1/1000000 秒).可以看到上面 timeval 到毫秒的转化 :</p>

<p><code>
jlong when = now.tv_sec * 1000LL + now.tv_usec / 1000;
</code></p>

<p>gettimeofday的实现是经 libc 进入内核，实际上是一个 system call 。详情参考 kernel 的代码。</p>

<p>关于 libc 和 内核的实现关系，我需要学习后再来讨论，可以参考下 <a href="http://www.win.tue.nl/~aeb/linux/lk/lk-3.html">user space and libc interface</a></p>

<p>获取系统已经运行的时间有几个不同的 API , 都在 SystemClock.java 中:</p>

<ul>
<li>elapsedRealtime ()                //Returns milliseconds since boot, including time spent in sleep.</li>
<li>elapsedRealtimeNanos ()          //Returns nanoseconds since boot, including time spent in sleep.</li>
<li>uptimeMillis ()                  //Returns milliseconds since boot, not counting time spent in deep sleep.</li>
</ul>


<p><code>elapsedRealtime()</code> 和 <code>elapsedRealtimeNanos()</code> 包含系统 sleep 的时间，而 <code>uptimeMillis()</code> 不包含 sleep 的时间。参考 <a href="http://developer.android.com/reference/android/os/SystemClock.html">SystemClock</a></p>

<p><code>elapsedRealtime()</code> api 用的比较多，Android 系统里面 Settings->About phone->Status->Uptime 显示的就是这个时间。Settings->Battery 显示的时间也是用这个时间计算出来的（减去上一次 unplug 的时间）。</p>

<p>来看下 <code>elapsedRealtime</code> 的底层实现：</p>

<p><code>java SystemClock.java
 native public static long elapsedRealtime();
</code>
在 SystemClock 里用的是 native 的方法。</p>

<p>```cpp frameworks/base/core/jni/android_os_SystemClock.cpp
/<em>
 * native public static long elapsedRealtime();
 </em>/
static jlong android_os_SystemClock_elapsedRealtime(JNIEnv* env,</p>

<pre><code>    jobject clazz)
</code></pre>

<p>{</p>

<pre><code>return (jlong)elapsedRealtime();
</code></pre>

<p>}</p>

<p>```</p>

<p>cpp 中调用了libutils 中的方法 <code>elapsedRealtime()</code>.</p>

<p>```cpp system/core/libutils/SystemClock.cpp
/<em>
 * native public static long elapsedRealtime();
 </em>/
int64_t elapsedRealtime()
{</p>

<pre><code>return nanoseconds_to_milliseconds(elapsedRealtimeNano());
</code></pre>

<p>}</p>

<p>&ndash;></p>

<p>/<em>
 * native public static long elapsedRealtimeNano();
 </em>/
int64_t elapsedRealtimeNano()
{
&hellip;</p>

<pre><code>static int s_fd = -1;

if (s_fd == -1) {
    int fd = open("/dev/alarm", O_RDONLY);
    if (android_atomic_cmpxchg(-1, fd, &amp;s_fd)) {
        close(fd);
    }
}

result = ioctl(s_fd,
        ANDROID_ALARM_GET_TIME(ANDROID_ALARM_ELAPSED_REALTIME), &amp;ts);

if (result == 0) {
    timestamp = seconds_to_nanoseconds(ts.tv_sec) + ts.tv_nsec;
    checkTimeStamps(timestamp, &amp;prevTimestamp, &amp;prevMethod, METHOD_IOCTL);
    return timestamp;
}
</code></pre>

<p>&hellip;
}
```</p>

<p>和闹钟的提醒功能相似，<code>elapsedRealtimeNano()</code> 也是通过 <code>/dev/alarm</code> 的 ioctl 来完成的，具体的实现要参看 driver 的代码了。</p>

<p>好了，获取当前时间(UTC)通过 kernel system call 完成， 获取系统运行时间通过 ioctl
<code>/dev/alarm</code> 来完成。</p>

<p>Alarm/Clock 系统还需要提供的一个功能是设置/同步时间。由于手机芯片中缺少一个断电之后能继续维持时间的模块，所以，拔掉电池之后再开机之后时间会出现偏差（如果没有同步或手动设置时间)。</p>

<p>在 Android 系统中， Settings-> Date &amp; Time  &ndash;> 提供了设置时间和同步时间的UI 接口。
Date 和 Time 的设置都是使用 AlarmManagerService 提供的 <code>setTime</code> 接口。</p>

<p>```java AlarmManagerService.java</p>

<pre><code>public void setTime(long millis) {
    mContext.enforceCallingOrSelfPermission(
            "android.permission.SET_TIME",
            "setTime");  //检查 permission

    SystemClock.setCurrentTimeMillis(millis);
}
</code></pre>

<p>```</p>

<p>AlarmManagerService 调用了 SystemClock 的 api <code>setCurrentTimeMillis</code>.</p>

<p>```java SystemClock.java</p>

<pre><code>/** 
 * Sets the current wall time, in milliseconds.  Requires the calling
 * process to have appropriate permissions.
 *
 * @return if the clock was successfully set to the specified time.
 */
native public static boolean setCurrentTimeMillis(long millis);
</code></pre>

<p>```</p>

<p>SystemClock.java 调用了 native 方法</p>

<p>```cpp android_os_SystemClock.cpp
/<em>
 * Set the current time.  This only works when running as root.
 </em>/
static int setCurrentTimeMillis(int64_t millis)
{</p>

<p>&hellip;</p>

<pre><code>fd = open("/dev/alarm", O_RDWR);
</code></pre>

<p>&hellip;</p>

<pre><code>res = ioctl(fd, ANDROID_ALARM_SET_RTC, &amp;ts);
</code></pre>

<p>&hellip;
}
<code>``
android_os_SystemClock.cpp 是直接利用 ioctl</code>/dev/alarm` 调用到 driver 的 alarm 来完成。</p>

<p>同步时间的功能是定期的从 Google 的服务器 2.android.pool.ntp.org (默认配置) 获取时间,刷新的时间间隔有两种，一种长的是 24 h，一种短的是 60s。</p>

<p>参考代码:</p>

<ul>
<li>frameworks/base/services/java/com/android/server/NetworkTimeUpdateService.java</li>
<li>frameworks/base/core/java/android/util/NtpTrustedTime.java</li>
<li>frameworks/base/core/res/res/values/config.xml</li>
</ul>


<p>通过 ioctl <code>/dev/alarm</code> 操组 driver 的 alarm 模块来完成设置时间，通过定期和 Google 服务器 2.android.pool.ntp.org 同步来完成时间的同步。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[android properties data structure]]></title>
    <link href="http://SteveVallay.github.io/blog/2013/12/24/android-properties-data-structure/"/>
    <updated>2013-12-24T13:04:00+08:00</updated>
    <id>http://SteveVallay.github.io/blog/2013/12/24/android-properties-data-structure</id>
    <content type="html"><![CDATA[<p>写文章不应太多拘泥于细节：</p>

<ul>
<li>言简意赅</li>
<li>图胜于文</li>
<li>图文并茂</li>
<li>点到为止</li>
</ul>


<!-- more -->


<p>从 Jelly Bean 到 KitKat 版本， <code>properties</code> 的存储的数据结构还是有些变化的.</p>

<p>实际存储位置： <strong>/dev/__properties__</strong> 文件 (root RW， 其他只能 R)
<code>bash
ls -al /dev/__proper*
-rw-r--r-- root     root        65536 1970-01-14 05:26 __properties__
</code></p>

<p>关于 Jelly Bean（或者以前的)， 直接上张图，比较明了：</p>

<p><img src="/images/blog/prop_struct_jb.png" alt="jb proper data structure" /></p>

<p>先看下相关结构的定义:</p>

<p>```c  system/core/init/property_service.c
typedef struct {</p>

<pre><code>void *data;
size_t size;
int fd; 
</code></pre>

<p>} workspace;</p>

<p>```</p>

<p>```c bionic/libc/bionic/system_properties.c
struct prop_area {</p>

<pre><code>unsigned volatile count;
unsigned volatile serial;  //不知道这个是干什么的?
unsigned magic;
unsigned version;
unsigned reserved[4];
unsigned toc[1];
</code></pre>

<p>};</p>

<p>struct prop_info {</p>

<pre><code>char name[PROP_NAME_MAX];
unsigned volatile serial;
char value[PROP_VALUE_MAX];
</code></pre>

<p>};
```
toc[i] 里面存放的是 property name 的长度 (前 8 位) 和对应 proper_info 对应的地址 (后 24位)。
proper_info 的 serial (前 8 位) 保存的是 property value 的 length。</p>

<p>但是有几个问题:</p>

<ul>
<li>大小是不对的 , Jelly Bean 上大小是 65536, 可以放 495 个 properties.</li>
</ul>


<p>```c system/core/init/properties_service.c
/<em> (8 header words + 495 toc words) = 2012 bytes </em>/
/<em> 2016 bytes header and toc + 495 prop_infos @ 128 bytes = 65376 bytes </em>/</p>

<h1>define PA_COUNT_MAX  495</h1>

<h1>define PA_INFO_START 2016</h1>

<h1>define PA_SIZE       65536</h1>

<p>```</p>

<ul>
<li>share memory 是不对的, 这个图在 init 进程里面没什么问题。但是其他进程访问（读取的时候) 其实是将同样的文件(<strong>/dev/__properties__</strong>) map 了一份到自己的内存空间。所以每个进程的这个结构是自己的，不是共享的。</li>
</ul>


<p>KitKat ：</p>

<p>KK 上总大小是  128*1024</p>

<p>数据结构:
```c bionic/libc/bionic/system_properties.c
struct prop_area {</p>

<pre><code>unsigned bytes_used;
unsigned volatile serial;
unsigned magic;
unsigned version;
unsigned reserved[28];
char data[0];
</code></pre>

<p>};</p>

<p>struct prop_info {</p>

<pre><code>unsigned volatile serial;
char value[PROP_VALUE_MAX];
char name[0];
</code></pre>

<p>};</p>

<p>struct prop_bt {</p>

<pre><code>uint8_t namelen;
uint8_t reserved[3];

prop_off_t prop;

prop_off_t left;
prop_off_t right;

prop_off_t children;

char name[0];
</code></pre>

<p>};</p>

<p>```</p>

<p>Kitkat 上 proper info 的存储已经改为 bTree 了，bytes_used 用来记录存储这些信息所使用的空间。</p>

<p><code>c bionic/libc/bionic/system_properties.c
 * +-----+   children    +----+   children    +--------+
 * |     |--------------&gt;| ro |--------------&gt;| secure |
 * +-----+               +----+               +--------+
 *                       /    \                /   |
 *                 left /      \ right   left /    |  prop   +===========+
 *                     v        v            v     +--------&gt;| ro.secure |
 *                  +-----+   +-----+     +-----+            +-----------+
 *                  | net |   | sys |     | com |            |     1     |
 *                  +-----+   +-----+     +-----+            +===========+
</code></p>

<p>好了， 就到这里吧! 感谢 ～</p>

<p>参考文档: <a href="http://rxwen.blogspot.com/2010/01/android-property-system.html">http://rxwen.blogspot.com/2010/01/android-property-system.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[android system properties dynamic]]></title>
    <link href="http://SteveVallay.github.io/blog/2013/12/23/android-system-properties2/"/>
    <updated>2013-12-23T10:17:00+08:00</updated>
    <id>http://SteveVallay.github.io/blog/2013/12/23/android-system-properties2</id>
    <content type="html"><![CDATA[<p>静态的程序代码和程序运行时的状态，有很大的不同。理解代码，要理解其运行时的样子。</p>

<!--more-->


<p>这一篇主要说说 android property service 的运行时状态。</p>

<p>先来看看这个图大致理解一下:</p>

<p><img src="/images/blog/android_property.png" alt="android-property" /></p>

<p>可以查看下手机的 /dev/__properties__ 文件(Kitkat 4.4) ：</p>

<p>```</p>

<h1>ls -al /dev/<em>*__proper</em></h1>

<p>-rw-r&mdash;r&mdash; root     root        65536 1970-01-12 05:24 <strong>properties</strong>
```</p>

<p>Init 进程，创建 <strong>/dev/__properties__</strong> 文件，map 到内存，然后从 <strong>/default.prop</strong>等文件中加载 properties, 写入 <strong>/dev/__properties__</strong>. 然后启动 property_service , 就是建立一个 <code>property_service</code> 的 socket ，监听这个 socket ，其他进程通过向这个 socket 发送 proper_set 的消息来完成 properties 的设置。</p>

<p>proper_get 是在每个进程在初始化时(libc中) 建立了 <strong>/dev/__properties__</strong>到内存的 map ，得到了可以直接访问的 address，可以直接遍历 properties 的存储空间完成查找.</p>

<p>下面细细到来：</p>

<p>Init 进程，Android 用户空间的第一个进程，内核启动之后会执行这个 init 程序。进入到 init 的main 函数。 在 init.c 的 main 函数里面，初始化 property 相关的存储空间。</p>

<p><strong>system/core/init/init.c</strong></p>

<p><code>c
 property_init();
</code></p>

<p><code>property_init</code> 是调用 property_service.c 的方法。</p>

<p><strong>/system/core/init/property_service.c</strong>
```
 void property_init(void)
 {</p>

<pre><code> init_property_area();
</code></pre>

<p> }</p>

<p>static int init_property_area(void)
{</p>

<pre><code>if (property_area_inited)
    return -1;

if(__system_property_area_init()) //关键这个
    return -1;

if(init_workspace(&amp;pa_workspace, 0))
    return -1;

fcntl(pa_workspace.fd, F_SETFD, FD_CLOEXEC);

property_area_inited = 1;
return 0;
</code></pre>

<p>}
```</p>

<p><code>__system_property_area_init</code> 方法在 <strong>bionic/libc/bionic/system_properties.c</strong></p>

<p>```c
int __system_property_area_init()
{</p>

<pre><code>return map_prop_area_rw();
</code></pre>

<p>}</p>

<p>static int map_prop_area_rw()
{</p>

<pre><code>prop_area *pa;
int fd;
int ret;

/* dev is a tmpfs that we can use to carve a shared workspace
 * out of, so let's do that...
 */
fd = open(property_filename, O_RDWR | O_CREAT | O_NOFOLLOW | O_CLOEXEC |
        O_EXCL, 0444);
if (fd &lt; 0) {
    if (errno == EACCES) {
        /* for consistency with the case where the process has already
         * mapped the page in and segfaults when trying to write to it
         */
        abort();
    }
    return -1;
}

ret = fcntl(fd, F_SETFD, FD_CLOEXEC);
if (ret &lt; 0)
    goto out;

if (ftruncate(fd, PA_SIZE) &lt; 0)
    goto out;

pa_size = PA_SIZE;
pa_data_size = pa_size - sizeof(prop_area);
compat_mode = false;

pa = mmap(NULL, pa_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
if(pa == MAP_FAILED)
    goto out;

memset(pa, 0, pa_size);
pa-&gt;magic = PROP_AREA_MAGIC;
pa-&gt;version = PROP_AREA_VERSION;
/* reserve root node */
pa-&gt;bytes_used = sizeof(prop_bt);

/* plug into the lib property services */
__system_property_area__ = pa;

close(fd);
return 0;
</code></pre>

<p>out:</p>

<pre><code>close(fd);
return -1;
</code></pre>

<p>}</p>

<p>```</p>

<p>首先创建 <strong>/dev/__properties__</strong> ，并且用 <code>mmap</code> 映射到内存.（通过变量<code>__system_property_area__</code> 的共享，完成 property_service 和 libc 中 properties 相关的交互。)</p>

<p>```c</p>

<h1>define PROP_FILENAME &ldquo;/dev/<strong>properties</strong>&rdquo;</h1>

<p>static char property_filename[PATH_MAX] = PROP_FILENAME;</p>

<p> fd = open(property_filename, O_RDWR | O_CREAT | O_NOFOLLOW | O_CLOEXEC |</p>

<pre><code>        O_EXCL, 0444);
</code></pre>

<p>&hellip;</p>

<pre><code>pa = mmap(NULL, pa_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);

/* plug into the lib property services */
__system_property_area__ = pa;
</code></pre>

<p>```</p>

<p>回到 init.c , 加载 boot defults properties：</p>

<p>init.c
<code>c
 property_load_boot_defaults();
</code></p>

<p>property_service.c:
```c</p>

<h1>define PROP_PATH_RAMDISK_DEFAULT  &ldquo;/default.prop&rdquo;</h1>

<p> void property_load_boot_defaults(void)
 {</p>

<pre><code> load_properties_from_file(PROP_PATH_RAMDISK_DEFAULT);
</code></pre>

<p> }
```</p>

<p><code>load_properties_from_file</code> 这个里面就是读取文件，然后 <code>set_property</code>。</p>

<p>回到 init.c , 启动 property service :</p>

<p>init.c:
```c
 queue_builtin_action(property_service_init_action, &ldquo;property_service_init&rdquo;);</p>

<p>static int property_service_init_action(int nargs, char **args)
{</p>

<pre><code>/* read any property files on system or data and
 * fire up the property service.  This must happen
 * after the ro.foo properties are set above so
 * that /data/local.prop cannot interfere with them.
 */
start_property_service();

/* update with vendor-specific property runtime
 * overrides
 */
vendor_load_properties();
return 0;
</code></pre>

<p>}</p>

<p>```</p>

<p>在 <code>start_property_service</code> 中，加载 properties (/system/build.prop, /system/default.prop, /data/property/xxx)，创建 <strong>/dev/socket/property_service</strong> 这个 socket, 并且监听这个 socket 来接受 set property 的消息。</p>

<p>property_service.c:
```c</p>

<p>void start_property_service(void)
{</p>

<pre><code>int fd; 

load_properties_from_file(PROP_PATH_SYSTEM_BUILD);
load_properties_from_file(PROP_PATH_SYSTEM_DEFAULT);
load_override_properties();
/* Read persistent properties after all default values have been loaded. */
load_persistent_properties();

fd = create_socket(PROP_SERVICE_NAME, SOCK_STREAM, 0666, 0, 0); 
if(fd &lt; 0) return;
fcntl(fd, F_SETFD, FD_CLOEXEC);
fcntl(fd, F_SETFL, O_NONBLOCK);

listen(fd, 8); 
property_set_fd = fd; 
</code></pre>

<p>}
```</p>

<p>回到 init.c :</p>

<p>init 进程在 main 函数的最后，进入一个无限循环，等待 <strong>/dev/socket/property_service</strong> 和其他 fd 的事件并处理。</p>

<p>```c</p>

<pre><code>for(;;) {
    int nr, i, timeout = -1;

    execute_one_command();
    restart_processes();

    if (!property_set_fd_init &amp;&amp; get_property_set_fd() &gt; 0) { 
        ufds[fd_count].fd = get_property_set_fd();
        ufds[fd_count].events = POLLIN;
        ufds[fd_count].revents = 0; 
        fd_count++;
        property_set_fd_init = 1; 
    }    
    if (!signal_fd_init &amp;&amp; get_signal_fd() &gt; 0) { 
        ufds[fd_count].fd = get_signal_fd();
        ufds[fd_count].events = POLLIN;
        ufds[fd_count].revents = 0; 
        fd_count++;
        signal_fd_init = 1; 
    }    
    if (!keychord_fd_init &amp;&amp; get_keychord_fd() &gt; 0) { 
        ufds[fd_count].fd = get_keychord_fd();
        ufds[fd_count].events = POLLIN;
        ufds[fd_count].revents = 0; 
        fd_count++;
        keychord_fd_init = 1; 
    }    
    if (process_needs_restart) {
        timeout = (process_needs_restart - gettime()) * 1000;
        if (timeout &lt; 0) 
            timeout = 0; 
    }    

    if (!action_queue_empty() || cur_action)
        timeout = 0;
</code></pre>

<h1>if BOOTCHART</h1>

<pre><code>    if (bootchart_count &gt; 0) {
        if (timeout &lt; 0 || timeout &gt; BOOTCHART_POLLING_MS)
            timeout = BOOTCHART_POLLING_MS;
        if (bootchart_step() &lt; 0 || --bootchart_count == 0) {
            bootchart_finish();
            bootchart_count = 0;
        }
    }
</code></pre>

<h1>endif</h1>

<pre><code>    nr = poll(ufds, fd_count, timeout);
    if (nr &lt;= 0)
        continue;

    for (i = 0; i &lt; fd_count; i++) {
        if (ufds[i].revents == POLLIN) {
            if (ufds[i].fd == get_property_set_fd())
                handle_property_set_fd();                 //关键这里
            else if (ufds[i].fd == get_keychord_fd())
                handle_keychord();
            else if (ufds[i].fd == get_signal_fd())
                handle_signal();
        }
    }
}
</code></pre>

<p>```</p>

<p><code>handler_property_set_fd</code> 里面接收 <code>/dev/socket/property_service</code> 的消息并处理。</p>

<p>property_service.c:</p>

<p>```c
void handle_property_set_fd()
{</p>

<pre><code>prop_msg msg;
int s; 
int r;  
int res;    
struct ucred cr;
struct sockaddr_un addr;
socklen_t addr_size = sizeof(addr);
socklen_t cr_size = sizeof(cr);
char * source_ctx = NULL;

if ((s = accept(property_set_fd, (struct sockaddr *) &amp;addr, &amp;addr_size)) &lt; 0) {
    return;
}   

/* Check socket options here */
if (getsockopt(s, SOL_SOCKET, SO_PEERCRED, &amp;cr, &amp;cr_size) &lt; 0) {
    close(s);
    ERROR("Unable to receive socket options\n");
    return;     
}           

r = TEMP_FAILURE_RETRY(recv(s, &amp;msg, sizeof(msg), 0));
if(r != sizeof(prop_msg)) {
    ERROR("sys_prop: mis-match msg size received: %d expected: %d errno: %d\n",
          r, sizeof(prop_msg), errno);
    close(s);
    return;
}
switch(msg.cmd) {
case PROP_MSG_SETPROP:                              //处理 set proper 请求
    msg.name[PROP_NAME_MAX-1] = 0;
    msg.value[PROP_VALUE_MAX-1] = 0;

    if (!is_legal_property_name(msg.name, strlen(msg.name))) {
        ERROR("sys_prop: illegal property name. Got: \"%s\"\n", msg.name);
        close(s);
        return;
    }

    getpeercon(s, &amp;source_ctx);

    if(memcmp(msg.name,"ctl.",4) == 0) {
        // Keep the old close-socket-early behavior when handling
        // ctl.* properties.
        close(s);
        if (check_control_perms(msg.value, cr.uid, cr.gid, source_ctx)) {
            handle_control_message((char*) msg.name + 4, (char*) msg.value);
        } else {
            ERROR("sys_prop: Unable to %s service ctl [%s] uid:%d gid:%d pid:%d\n",
                    msg.name + 4, msg.value, cr.uid, cr.gid, cr.pid);
        }
    } else {
        if (check_perms(msg.name, cr.uid, cr.gid, source_ctx)) {
            property_set((char*) msg.name, (char*) msg.value);    //设置 prop
        } else {
            ERROR("sys_prop: permission denied uid:%d  name:%s\n",
                  cr.uid, msg.name);
        }

        // Note: bionic's property client code assumes that the
        // property server will not close the socket until *AFTER*
        // the property is written to memory.
        close(s);
    }
    freecon(source_ctx);
    break;

default:
    close(s);
    break;
}
</code></pre>

<p>}
```</p>

<p>在 <code>property_set</code> 之前会 <code>check_perms</code>, 不同的 property_set 需要什么权限呢?</p>

<p>```c
/<em> White list of permissions for setting property services. </em>/
struct {</p>

<pre><code>const char *prefix;
unsigned int uid;
unsigned int gid;
</code></pre>

<p>} property_perms[] = {</p>

<pre><code>{ "net.rmnet0.",      AID_RADIO,    0 },
{ "net.gprs.",        AID_RADIO,    0 },
{ "net.ppp",          AID_RADIO,    0 },
{ "net.qmi",          AID_RADIO,    0 },
{ "net.lte",          AID_RADIO,    0 },
{ "net.cdma",         AID_RADIO,    0 },
{ "ril.",             AID_RADIO,    0 },
{ "gsm.",             AID_RADIO,    0 },
{ "persist.radio",    AID_RADIO,    0 },
{ "net.dns",          AID_RADIO,    0 },
{ "sys.usb.config",   AID_RADIO,    0 },
{ "net.",             AID_SYSTEM,   0 },
{ "dev.",             AID_SYSTEM,   0 },
{ "runtime.",         AID_SYSTEM,   0 },
{ "hw.",              AID_SYSTEM,   0 },
{ "sys.",             AID_SYSTEM,   0 },
{ "sys.powerctl",     AID_SHELL,    0 },
{ "service.",         AID_SYSTEM,   0 },
{ "wlan.",            AID_SYSTEM,   0 },
{ "bluetooth.",       AID_BLUETOOTH,   AID_SYSTEM },
{ "dhcp.",            AID_SYSTEM,   0 },
{ "dhcp.",            AID_DHCP,     0 },
{ "debug.",           AID_SYSTEM,   0 },
{ "debug.",           AID_SHELL,    0 },
{ "log.",             AID_SHELL,    0 },
{ "service.adb.root", AID_SHELL,    0 },
{ "service.adb.tcp.port", AID_SHELL,    0 },
{ "persist.sys.",     AID_SYSTEM,   0 },
{ "persist.service.", AID_SYSTEM,   0 },
{ "persist.security.", AID_SYSTEM,   0 },
{ "persist.service.bdroid.", AID_BLUETOOTH,   0 },
{ "selinux."         , AID_SYSTEM,   0 },
{ NULL, 0, 0 } 
</code></pre>

<p>};
```</p>

<p>接着就 <code>property_set</code>:</p>

<p>先查询有的话，就 <code>__system_property_update</code> , 没有就 <code>__system_property_add</code> ,如果是 <code>persist.</code>的话，要 <code>write_persistent_property</code> 写入到 <strong>/data/property/xxx</strong></p>

<p>```c
int property_set(const char <em>name, const char </em>value)
{</p>

<pre><code>prop_info *pi;
int ret;

size_t namelen = strlen(name);
size_t valuelen = strlen(value);

if (!is_legal_property_name(name, namelen)) return -1; 
if (valuelen &gt;= PROP_VALUE_MAX) return -1; 

pi = (prop_info*) __system_property_find(name);

if(pi != 0) {
    /* ro.* properties may NEVER be modified once set */
    if(!strncmp(name, "ro.", 3)) return -1; 

    __system_property_update(pi, value, valuelen);
} else {
    ret = __system_property_add(name, namelen, value, valuelen);
    if (ret &lt; 0) {
        ERROR("Failed to set '%s'='%s'\n", name, value);
        return ret;
    }   
}   
/* If name starts with "net." treat as a DNS property. */
if (strncmp("net.", name, strlen("net.")) == 0)  {
    if (strcmp("net.change", name) == 0) {
        return 0;
    }   
   /*  
    * The 'net.change' property is a special property used track when any
    * 'net.*' property name is updated. It is _ONLY_ updated here. Its value
    * contains the last updated 'net.*' property.
    */
    property_set("net.change", name);
} else if (persistent_properties_loaded &amp;&amp;
        strncmp("persist.", name, strlen("persist.")) == 0) {
    /*  
     * Don't write properties to disk until after we have read all default properties
     * to prevent them from being overwritten by default values.
     */
    write_persistent_property(name, value);
} else if (strcmp("selinux.reload_policy", name) == 0 &amp;&amp;
           strcmp("1", value) == 0) {
    selinux_reload_policy();
}
property_changed(name, value);
return 0;
</code></pre>

<p>}
```</p>

<p>OK， <code>proper_set</code> 流程先到这里，下面来看看 <code>proper_get</code> . <code>proper_get</code> 直接向下到 libc 的 <code>__system_property_get</code> 的 api.</p>

<p><strong>/bionic/libc/bionic/system_properties.c</strong></p>

<p>```c
int __system_property_get(const char <em>name, char </em>value)
{</p>

<pre><code>const prop_info *pi = __system_property_find(name);

if(pi != 0) {
    return __system_property_read(pi, 0, value);
} else {
    value[0] = 0;
    return 0;
}   
</code></pre>

<p>}
```</p>

<p>这里是调用了 <code>__system_property_find</code> 来查找这个值。在往下看：
```
const prop_info <em>__system_property_find(const char </em>name)
{</p>

<pre><code>if (__predict_false(compat_mode)) {  //貌似没打开 compat_mode 
    return __system_property_find_compat(name);
}
return find_property(root_node(), name, strlen(name), NULL, 0, false); //看这里
</code></pre>

<p>}
```</p>

<p>这里调用 <code>find_property</code> 来访问 <code>root_node()</code>, 什么是 <code>root_node()</code>?</p>

<p>```c
static prop_bt *root_node()
{</p>

<pre><code>return to_prop_obj(0);
</code></pre>

<p>}</p>

<p>static void *to_prop_obj(prop_off_t off)
{</p>

<pre><code>if (off &gt; pa_data_size)
    return NULL;

return __system_property_area__-&gt;data + off;
</code></pre>

<p>}
```</p>

<p>实际上获取 <code>__system_property_area__-&gt;data</code>的地址开始访问。OK, <code>__system_property_area__</code> 是哪里？ 正是 <strong>/dev/<strong>properties</strong></strong> map 到内存的地址。</p>

<p>init.c 进程调用了 system_properties.c 的 <code>__system_property_area_init</code> &ndash;> <code>map_prop_area_rw</code> 在这里：</p>

<p>创建 <code>property_filename</code>(/dev/_-properties__), <code>mmap</code> 到内存， 将地址赋值给 <code>__system_property_area__</code> 。</p>

<p>```c
static int map_prop_area_rw()
{
&hellip;
fd = open(property_filename, O_RDWR | O_CREAT | O_NOFOLLOW | O_CLOEXEC |</p>

<pre><code>        O_EXCL, 0444);
</code></pre>

<p>&hellip;
 pa = mmap(NULL, pa_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);</p>

<p>&hellip;
/<em> plug into the lib property services </em>/</p>

<pre><code>__system_property_area__ = pa;
</code></pre>

<p>&hellip;
}
```</p>

<p>但是，慢着！ 这些都是在 init 进程里面执行的，其他进程调用 <code>__system_property_find</code> 怎么可以直接访问 <code>__system_property_area__</code> ? 难道 其他进程和 init 共享了这个地址，这是不可能的，这个变量怎会传递到 init 的子进程？就算传递了，它们怎么可能访问相同的地址呢？它们可是不同进程啊，各自使用自己独享的内存空间啊！</p>

<p>所以，呵呵！ 其他进程肯定也对 <code>__system_property_area__</code> 进行初始化了！ 在哪里 ？
<strong>/bionic/libc/bionic/libc_init_common.cpp</strong> 中 调用了 <code>__system_properties_init()</code>
<code>c
void __libc_init_common(KernelArgumentBlock&amp; args) {
...
 __system_properties_init();
}
</code></p>

<p><strong>/bionic/libc/bionic/system_properties.c</strong>
```c
int __system_properties_init()
{</p>

<pre><code>return map_prop_area();
</code></pre>

<p>}</p>

<p>static int map_prop_area()
{
 &hellip;
 fd = open(property_filename, O_RDONLY | O_NOFOLLOW | O_CLOEXEC);
 &hellip;
prop_area *pa = mmap(NULL, pa_size, PROT_READ, MAP_SHARED, fd, 0);
&hellip;
 <strong>system_property_area</strong> = pa;
&hellip;
}
```</p>

<p>以 RDONLY 模式打开了 <code>/dev/__properties__</code> 文件，并且 mmap 到内存，将地址赋值给 <code>__system_property_area__</code> ！ 所以，其他进程可以直接访问 <code>__system_property_area__</code> 不过这个肯定和 init 进程里那个是不同的！！</p>

<p>OK！ 结束，下一篇讲讲 property 存储区的数据结构 ！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android System Properties]]></title>
    <link href="http://SteveVallay.github.io/blog/2013/12/13/android-systemproperties/"/>
    <updated>2013-12-13T23:41:00+08:00</updated>
    <id>http://SteveVallay.github.io/blog/2013/12/13/android-systemproperties</id>
    <content type="html"><![CDATA[<p>&mdash;直朝那个方向走，或许真的能到达那个地方。o(∩∩)o&hellip;哈哈</p>

<p>Property system 是 Android 系统中一个重要的 Feature，它以一个 service 的形式来管理系统的配置和状态，每个 property 都是一个 key/value 组，key 和 value 都是字符串。</p>

<p>这些配置和状态信息在 Android 的所有进程中都可以读取、设置和修改，所以 Property system 成了 Android 系统中控制全局配置的一种常用手段。你可以预置 system propterties 作为系统的初始设置，也可以运行是设置和改变 system properties 的值。</p>

<p>因此，system properties 经常作为一些特定 Feature 的控制开关，运行时根据 properties 的值来区分打开/关闭某个 Feature.由于在所有进程都可以访问，也可以用来在 Android 的不同进程间进行简单信息协调，Java 和 native 都不受限制。</p>

<p>下面我们就按自上而下的顺序看看 Android 的这个 Properties system 的实现（Kitkat 4.4)。</p>

<!--more-->


<p><img src="/images/blog/property-call-stack.png" alt="properties call stack" /></p>

<h4>Java 层</h4>

<p><strong>frameworks/base/core/java/android/os/SystemProperties.java</strong></p>

<p>java 层的接口在 <em>SysstemProperties.java</em> 这个文件中,经常使用的接口有以下几个：</p>

<p>```java
/<em>Get the value for the given key.</em>/
public static String get(String key)
public static String get(String key, String def)
public static int getInt(String key, int def)
public static long getLong(String key, long def）
public static boolean getBoolean(String key, boolean def)</p>

<p>/<em>Set the value for the given key.</em>/
public static void set(String key, String val)
```</p>

<p>简单来说就是 <code>get</code> 和 <code>set</code> 方法，都是静态方法，直接使用 SystemProperties.get/set 就可以访问。不过 SystemProperties 是一个 <em>hide</em> 的类，不在 SDK 的标准 API 中，也就意味着，在基于 SDK 的 app 开发中不能直接使用（可以尝试反射 ^_^)。</p>

<h4>Framework 层</h4>

<p>进到这几个方法的里面来看，就会发现，它们都是调用了 native 方法:</p>

<p>```java</p>

<pre><code>private static native String native_get(String key);
private static native String native_get(String key, String def);
private static native int native_get_int(String key, int def);
private static native long native_get_long(String key, long def);
private static native boolean native_get_boolean(String key, boolean def);
private static native void native_set(String key, String def);
</code></pre>

<p>```
这些 native 方法在哪里定义和实现呢 ？</p>

<p><strong>frameworks/base/core/jni/android_os_SystemProperties.cpp</strong>(android framework 的 native 实现在 <strong>/frameworks/base/core/jni</strong> 下面可以看到)</p>

<p>从代码可以知道，这一层只是调用底层接口，提供 JNI 支持。</p>

<p>```c++
static jstring SystemProperties_getSS(JNIEnv *env, jobject clazz,</p>

<pre><code>                                  jstring keyJ, jstring defJ);
</code></pre>

<p>static void SystemProperties_set(JNIEnv *env, jobject clazz,</p>

<pre><code>                                  jstring keyJ, jstring valJ);
</code></pre>

<p>&hellip;
```</p>

<p><strong>get/set</strong> 方法内部调用了两个底层接口：</p>

<p><code>c++
property_set(key,value);
property_get(key, buf,default);
</code>
这两个接口定义在哪里呢？</p>

<p>```c</p>

<h1>include &ldquo;cutils/properties.h&rdquo;</h1>

<p>```</p>

<p>这个.h 文件在 <strong>system/core/include/cutils/properties.h</strong></p>

<p>在这个文件中可以看到这两个函数的声明。</p>

<p><code>c
int property_get(const char *key, char *value, const char *default_value);
int property_set(const char *key, const char *value);
</code>
这两个函数的实现在哪里呢？ 在 <strong>properties.c</strong> 中</p>

<p><strong>system/core/libcutils/properties.c</strong></p>

<p>在这个文件中我们可以看到根据不同的宏定义有几种不同的实现。</p>

<p>```c</p>

<h1>ifdef HAVE_LIBC_SYSTEM_PROPERTIES</h1>

<h1>define <em>REALLY_INCLUDE_SYS__SYSTEM_PROPERTIES_H</em></h1>

<h1>include &lt;sys/_system_properties.h></h1>

<p>&hellip;</p>

<h1>elif defined(HAVE_SYSTEM_PROPERTY_SERVER)</h1>

<p>&hellip;</p>

<h1>else</h1>

<p>/<em> SUPER-cheesy place-holder implementation for Win32 </em>/</p>

<h1>include &lt;cutils/threads.h></h1>

<p>&hellip;
```
在实际的手机运行环境中，property system 使用的是第一种的实现，第二种是模拟器环境的实现，第三种嘛? 嘿嘿 ~</p>

<p>我们重点来看第一种好了，因为第一种是实际的手机运行环境。在这种实现中，同样是调用了两个类似的 <code>api</code>  <strong>__system_property_set</strong> 和 <strong>__system_property_get</strong> （在 <strong>sys/_system_properties.h</strong> 中声明的).</p>

<p>```c</p>

<h1>ifdef HAVE_LIBC_SYSTEM_PROPERTIES</h1>

<h1>define <em>REALLY_INCLUDE_SYS__SYSTEM_PROPERTIES_H</em></h1>

<h1>include &lt;sys/_system_properties.h></h1>

<p>int property_set(const char <em>key, const char </em>value)
{</p>

<pre><code>return __system_property_set(key, value);
</code></pre>

<p>}</p>

<p>int property_get(const char <em>key, char </em>value, const char *default_value)
{</p>

<pre><code>int len;

len = __system_property_get(key, value);
if(len &gt; 0) {
    return len;
}

if(default_value) {
    len = strlen(default_value);
    memcpy(value, default_value, len + 1);
}
return len;
</code></pre>

<p>}
```
先看一下 <strong>sys/_system_properties.h</strong> 中定义的几个基本结构.
<strong>bionic/libc/include/sys/_system_properties.h</strong></p>

<p>```</p>

<h1>define PROP_SERVICE_NAME &ldquo;property_service&rdquo;</h1>

<h1>define TOC_NAME_LEN(toc)       ((toc) >> 24)</h1>

<h1>define TOC_TO_INFO(area, toc)  ((prop_info<em>) (((char</em>) area) + ((toc) &amp; 0xFFFFFF)))</h1>

<p>struct prop_area {</p>

<pre><code>unsigned volatile count;
unsigned volatile serial;
unsigned magic;
unsigned version;
unsigned reserved[4];
unsigned toc[1];
</code></pre>

<p>};</p>

<p>struct prop_info {</p>

<pre><code>char name[PROP_NAME_MAX];
unsigned volatile serial;
char value[PROP_VALUE_MAX];
</code></pre>

<p>};</p>

<p>struct prop_msg
{</p>

<pre><code>unsigned cmd;
char name[PROP_NAME_MAX];
char value[PROP_VALUE_MAX];
</code></pre>

<p>};</p>

<h1>define PROP_MSG_SETPROP 1</h1>

<h1>define PROP_PATH_RAMDISK_DEFAULT  &ldquo;/default.prop&rdquo;</h1>

<h1>define PROP_PATH_SYSTEM_BUILD     &ldquo;/system/build.prop&rdquo;</h1>

<h1>define PROP_PATH_SYSTEM_DEFAULT   &ldquo;/system/default.prop&rdquo;</h1>

<h1>define PROP_PATH_LOCAL_OVERRIDE   &ldquo;/data/local.prop&rdquo;</h1>

<p>```</p>

<p>这两个 <code>api</code> 又在哪里实现呢？ ^_^
查看 <strong>bionic/libc/bionic/system_properties.c</strong></p>

<p>```c
static const char property_service_socket[] = &ldquo;/dev/socket/&rdquo; PROP_SERVICE_NAME;</p>

<p>int __system_property_get(const char <em>name, char </em>value)
{</p>

<pre><code>const prop_info *pi = __system_property_find(name);

if(pi != 0) {
    return __system_property_read(pi, 0, value);
} else {
    value[0] = 0;
    return 0;
}
</code></pre>

<p>}</p>

<p>int __system_property_set(const char <em>key, const char </em>value)
{</p>

<pre><code>int err;
int tries = 0;
int update_seen = 0;
prop_msg msg;

if(key == 0) return -1;
if(value == 0) value = "";
if(strlen(key) &gt;= PROP_NAME_MAX) return -1;
if(strlen(value) &gt;= PROP_VALUE_MAX) return -1;

memset(&amp;msg, 0, sizeof msg);
msg.cmd = PROP_MSG_SETPROP;
strlcpy(msg.name, key, sizeof msg.name);
strlcpy(msg.value, value, sizeof msg.value);

err = send_prop_msg(&amp;msg);
if(err &lt; 0) {
    return err;
}

return 0;
</code></pre>

<p>}</p>

<p>```</p>

<p>的确在这里找到了 <strong>__system_property_get</strong> 和 <strong>__system_property_set</strong> ,这两个函数的实现有包含了 <strong>__system_property_find</strong> <strong>__system_property_read</strong> 和 <strong>send_prop_msg</strong>
```
const prop_info <em>__system_property_find(const char </em>name)
{</p>

<pre><code>prop_area *pa = __system_property_area__;
unsigned count = pa-&gt;count;
unsigned *toc = pa-&gt;toc;
unsigned len = strlen(name);
prop_info *pi;

while(count--) {
    unsigned entry = *toc++;
    if(TOC_NAME_LEN(entry) != len) continue;

    pi = TOC_TO_INFO(pa, entry);
    if(memcmp(name, pi-&gt;name, len)) continue;

    return pi;
}

return 0;
</code></pre>

<p>}</p>

<p>int __system_property_read(const prop_info <em>pi, char </em>name, char *value)
{</p>

<pre><code>unsigned serial, len;

for(;;) {
    serial = pi-&gt;serial;
    while(SERIAL_DIRTY(serial)) {
        __futex_wait((volatile void *)&amp;pi-&gt;serial, serial, 0);
        serial = pi-&gt;serial;
    }
    len = SERIAL_VALUE_LEN(serial);
    memcpy(value, pi-&gt;value, len + 1);
    if(serial == pi-&gt;serial) {
        if(name != 0) {
            strcpy(name, pi-&gt;name);
        }
        return len;
    }
}
</code></pre>

<p>}</p>

<p>static int send_prop_msg(prop_msg *msg)
{</p>

<pre><code>struct pollfd pollfds[1];
struct sockaddr_un addr;
socklen_t alen;
size_t namelen;
int s;
int r;
int result = -1;

s = socket(AF_LOCAL, SOCK_STREAM, 0);
if(s &lt; 0) {
    return result;
}

memset(&amp;addr, 0, sizeof(addr));
namelen = strlen(property_service_socket);
strlcpy(addr.sun_path, property_service_socket, sizeof addr.sun_path);
addr.sun_family = AF_LOCAL;
alen = namelen + offsetof(struct sockaddr_un, sun_path) + 1;

if(TEMP_FAILURE_RETRY(connect(s, (struct sockaddr *) &amp;addr, alen)) &lt; 0) {
    close(s);
    return result;
}

r = TEMP_FAILURE_RETRY(send(s, msg, sizeof(prop_msg), 0));
if(r == sizeof(prop_msg)) {
    // We successfully wrote to the property server but now we
    // wait for the property server to finish its work.  It
    // acknowledges its completion by closing the socket so we
    // poll here (on nothing), waiting for the socket to close.
    // If you 'adb shell setprop foo bar' you'll see the POLLHUP
    // once the socket closes.  Out of paranoia we cap our poll
    // at 250 ms.
    pollfds[0].fd = s;
    pollfds[0].events = 0;
    r = TEMP_FAILURE_RETRY(poll(pollfds, 1, 250 /* ms */));
    if (r == 1 &amp;&amp; (pollfds[0].revents &amp; POLLHUP) != 0) {
        result = 0;
    } else {
        // Ignore the timeout and treat it like a success anyway.
        // The init process is single-threaded and its property
        // service is sometimes slow to respond (perhaps it's off
        // starting a child process or something) and thus this
        // times out and the caller thinks it failed, even though
        // it's still getting around to it.  So we fake it here,
        // mostly for ctl.* properties, but we do try and wait 250
        // ms so callers who do read-after-write can reliably see
        // what they've written.  Most of the time.
        // TODO: fix the system properties design.
        result = 0;
    }
}

close(s);
return result;
</code></pre>

<p>}</p>

<p>```
看到这里，我们大概知道 get 是从一个 prop_info 的结构提中读取，而 set 的则是向 <strong>property_service_socket(&ldquo;/dev/socket/property_service&rdquo;)</strong> 发送数据。但不免又有很多疑问，property 存储在哪，数据结构是怎样的？proper_set 发送socket 数据是谁来接收和处理的？ property system 是如何启动的？</p>

<p>好吧，我们先来总结一下 Android system properties 相关的目录和文件吧。</p>

<p>Java 层：</p>

<ul>
<li>frameworks/base/core/java/android/os/SystemProperties.java</li>
</ul>


<p><code>java
/**
 * Gives access to the system properties store.  The system properties
 * store contains a list of string key-value pairs.
 *
 * {@hide}
 */
</code></p>

<p>native 层：</p>

<p>Android framework 的 native 实现，或者成为 runtime 都是在 <strong>frameworks/base/core/jni</strong> 目录下。</p>

<p>和 properties 相关的文件：
&ndash; frameworks/base/core/jni/android_os_SystemProperties.cpp</p>

<p>```c</p>

<h1>include &ldquo;cutils/properties.h&rdquo;</h1>

<p>```</p>

<p>cutils:</p>

<p><strong>system</strong> 目录，这个目录有什么用呢 ?</p>

<blockquote><p>System &ndash; source code files for the core Android system. That is the minimal Linux system that is started before the Dalvik VM and any java based services are enabled. This includes the source code for the init process and the default init.rc script that provide the dynamic configuration of the platform.</p></blockquote>

<ul>
<li>system/core/libcutils/properties.c  //包含了 _system_properties.h</li>
<li>system/core/include/cutils/properties.h //properties.c 的对外接口 被 jni 包含.</li>
<li>system/core/init/property_service.h  //property_service 的对外接口</li>
<li>system/core/init/property_service.c  //</li>
<li>system/core/init/init.c</li>
</ul>


<p>libc:</p>

<p><strong>Bionic</strong> 这个目录又是干什么的呢？</p>

<blockquote><p>Bionic &ndash; the C-runtime for Android. Note that Android is not using glibc like most Linux distributions. Instead the c-library is called bionic and is based mostly on BSD-derived sources. In this folder you will find the source for the c-library, math and other core runtime libraries.</p></blockquote>

<ul>
<li>bionic/libc/include/sys/_system_properties.h //包含了下面的 system_properties.h</li>
<li>bionic/libc/include/sys/system_properties.h //下面的system_properties.c 对外接口声明</li>
<li>/libc/bionic/system_properties.c</li>
</ul>

]]></content>
  </entry>
  
</feed>
